{
  "version": 3,
  "sources": ["../bundle-Bj5wZp/checked-fetch.js", "../bundle-Bj5wZp/strip-cf-connecting-ip-header.js", "../../../node_modules/mcp-lite/src/client-request-adapter.ts", "../../../node_modules/mcp-lite/src/constants.ts", "../../../node_modules/mcp-lite/src/errors.ts", "../../../node_modules/mcp-lite/src/utils.ts", "../../../node_modules/mcp-lite/src/types.ts", "../../../node_modules/mcp-lite/src/validation.ts", "../../../node_modules/mcp-lite/src/context.ts", "../../../node_modules/mcp-lite/src/uri-template.ts", "../../../node_modules/mcp-lite/src/core.ts", "../../../node_modules/mcp-lite/src/session-store.ts", "../../../node_modules/mcp-lite/src/sse-writer.ts", "../../../node_modules/mcp-lite/src/transport-http/http-responses.ts", "../../../node_modules/mcp-lite/src/transport-http/transport-http.ts", "../../../src/index.ts", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-Bj5wZp/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-Bj5wZp/middleware-loader.entry.ts"],
  "sourceRoot": "/Users/scottaskinosie/Documents/hacknight/cloudflare_10-28-25/World-Wild-Web-AI-And-MCP-Hack-Night/cook-mcp-wrapper/.wrangler/tmp/dev-NIbaRR",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "function stripCfConnectingIPHeader(input, init) {\n\tconst request = new Request(input, init);\n\trequest.headers.delete(\"CF-Connecting-IP\");\n\treturn request;\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\treturn Reflect.apply(target, thisArg, [\n\t\t\tstripCfConnectingIPHeader.apply(null, argArray),\n\t\t]);\n\t},\n});\n", "export interface ClientRequestAdapter {\n  /**\n   * Create and track a pending client request. Returns a promise that\n   * resolves when a matching JSON-RPC response is received (or rejects on timeout).\n   */\n  createPending(\n    sessionId: string | undefined,\n    requestId: string | number,\n    options?: { timeout_ms?: number },\n  ): { promise: Promise<unknown> };\n\n  /**\n   * Resolve a pending request by providing the JSON-RPC response payload.\n   * Returns true when a pending entry was found and resolved.\n   */\n  resolvePending(\n    sessionId: string | undefined,\n    requestId: string | number,\n    response: unknown,\n  ): boolean;\n\n  /**\n   * Reject a pending request (e.g., timeout/cancel). Returns true when a\n   * pending entry was found and rejected.\n   */\n  rejectPending(\n    sessionId: string | undefined,\n    requestId: string | number,\n    reason: unknown,\n  ): boolean;\n}\n\ninterface PendingEntry {\n  resolve: (value: unknown) => void;\n  reject: (reason?: unknown) => void;\n  timer?: ReturnType<typeof setTimeout>;\n}\n\nfunction makeKey(\n  sessionId: string | undefined,\n  requestId: string | number,\n): string {\n  return `${sessionId ?? \"\"}:${String(requestId)}`;\n}\n\nexport class InMemoryClientRequestAdapter implements ClientRequestAdapter {\n  private pending = new Map<string, PendingEntry>();\n  private defaultTimeoutMs?: number;\n\n  constructor(options?: { defaultTimeoutMs?: number }) {\n    this.defaultTimeoutMs = options?.defaultTimeoutMs;\n  }\n\n  createPending(\n    sessionId: string | undefined,\n    requestId: string | number,\n    options?: { timeout_ms?: number },\n  ): { promise: Promise<unknown> } {\n    const key = makeKey(sessionId, requestId);\n\n    // Check if key already exists and clean up existing entry\n    const existingEntry = this.pending.get(key);\n    if (existingEntry) {\n      if (existingEntry.timer) {\n        clearTimeout(existingEntry.timer);\n      }\n      existingEntry.reject(\n        new Error(\"Request replaced by new request with same key\"),\n      );\n      this.pending.delete(key);\n    }\n\n    let resolve!: (value: unknown) => void;\n    let reject!: (reason?: unknown) => void;\n    const promise = new Promise<unknown>((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n\n    const entry: PendingEntry = { resolve, reject };\n\n    // Use provided timeout, or fall back to default timeout\n    const timeoutMs = options?.timeout_ms ?? this.defaultTimeoutMs;\n    if (timeoutMs && timeoutMs > 0) {\n      entry.timer = setTimeout(() => {\n        this.pending.delete(key);\n        reject(\n          new Error(\n            `Client request ${requestId} timed out after ${timeoutMs}ms`,\n          ),\n        );\n      }, timeoutMs);\n    }\n\n    this.pending.set(key, entry);\n    return { promise };\n  }\n\n  resolvePending(\n    sessionId: string | undefined,\n    requestId: string | number,\n    response: unknown,\n  ): boolean {\n    const key = makeKey(sessionId, requestId);\n    const entry = this.pending.get(key);\n    if (!entry) return false;\n    if (entry.timer) clearTimeout(entry.timer);\n    this.pending.delete(key);\n    entry.resolve(response);\n    return true;\n  }\n\n  rejectPending(\n    sessionId: string | undefined,\n    requestId: string | number,\n    reason: unknown,\n  ): boolean {\n    const key = makeKey(sessionId, requestId);\n    const entry = this.pending.get(key);\n    if (!entry) return false;\n    if (entry.timer) clearTimeout(entry.timer);\n    this.pending.delete(key);\n    entry.reject(reason);\n    return true;\n  }\n}\n", "export const JSON_RPC_VERSION = \"2.0\";\n\nexport const SUPPORTED_MCP_PROTOCOL_VERSIONS = {\n  V2025_03_26: \"2025-03-26\",\n  V2025_06_18: \"2025-06-18\",\n} as const;\n\nexport const SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST = Object.values(\n  SUPPORTED_MCP_PROTOCOL_VERSIONS,\n);\n\nexport const MCP_PROTOCOL_HEADER = \"MCP-Protocol-Version\";\n\nexport const MCP_SESSION_ID_HEADER = \"MCP-Session-Id\";\n\nexport const MCP_LAST_EVENT_ID_HEADER = \"Last-Event-ID\";\n\nexport const SSE_ACCEPT_HEADER = \"text/event-stream\";\n\nexport const METHODS = {\n  INITIALIZE: \"initialize\",\n  PING: \"ping\",\n  TOOLS: {\n    LIST: \"tools/list\",\n    CALL: \"tools/call\",\n  },\n  PROMPTS: {\n    LIST: \"prompts/list\",\n    GET: \"prompts/get\",\n  },\n  RESOURCES: {\n    LIST: \"resources/list\",\n    TEMPLATES_LIST: \"resources/templates/list\",\n    READ: \"resources/read\",\n    SUBSCRIBE: \"resources/subscribe\",\n    UNSUBSCRIBE: \"resources/unsubscribe\",\n  },\n  COMPLETION: {\n    COMPLETE: \"completion/complete\",\n  },\n  ELICITATION: {\n    CREATE: \"elicitation/create\",\n  },\n  SAMPLING: {\n    CREATE: \"sampling/createMessage\",\n  },\n  NOTIFICATIONS: {\n    CANCELLED: \"notifications/cancelled\",\n    INITIALIZED: \"notifications/initialized\",\n    PROGRESS: \"notifications/progress\",\n    ROOTS: {\n      LIST_CHANGED: \"notifications/roots/list_changed\",\n    },\n    TOOLS: {\n      LIST_CHANGED: \"notifications/tools/list_changed\",\n    },\n    PROMPTS: {\n      LIST_CHANGED: \"notifications/prompts/list_changed\",\n    },\n    RESOURCES: {\n      LIST_CHANGED: \"notifications/resources/list_changed\",\n    },\n  },\n  LOGGING: {\n    SET_LEVEL: \"logging/setLevel\",\n  },\n};\n\nexport const GLOBAL_NOTIFICATIONS = [\n  METHODS.NOTIFICATIONS.TOOLS.LIST_CHANGED,\n  METHODS.NOTIFICATIONS.PROMPTS.LIST_CHANGED,\n  METHODS.NOTIFICATIONS.RESOURCES.LIST_CHANGED,\n];\n\nexport const SSE_STREAM_ID = \"_GET_stream\";\n", "import type { JsonRpcError } from \"./types.js\";\n\nexport class RpcError extends Error {\n  public readonly code: number;\n  public readonly data?: unknown;\n  public readonly cause?: unknown;\n\n  constructor(code: number, message: string, data?: unknown, cause?: unknown) {\n    super(message);\n    this.name = \"RpcError\";\n    this.code = code;\n    this.data = data;\n    this.cause = cause;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n\n  toJson(): JsonRpcError {\n    return {\n      code: this.code,\n      message: this.message,\n      data: this.data,\n    };\n  }\n}\n", "import { RpcError } from \"./errors.js\";\nimport {\n  createJsonRpcError,\n  JSON_RPC_ERROR_CODES,\n  type JsonRpcId,\n  type JsonRpcRes,\n} from \"./types.js\";\n\n/**\n * Checks if a value is an object.\n * @param value - The value to check.\n * @returns True if the value is an object, false otherwise.\n */\nexport function isObject(value: unknown): value is object {\n  return typeof value === \"object\" && value !== null;\n}\n\n/**\n * Checks if a value is an object with a specific key.\n * @param value - The value to check.\n * @param key - The key to check for.\n * @returns True if the value is an object with the key, false otherwise.\n */\nexport function objectWithKey<T extends string>(\n  value: unknown,\n  key: T,\n): value is { [K in T]: unknown } {\n  return isObject(value) && key in value;\n}\n\n/**\n * Checks if a value is an object with a specific key and that the value for that key is not undefined.\n * @param value - The value to check.\n * @param key - The key to check for.\n * @returns True if the value is an object with the key that is defined, false otherwise.\n */\nexport function objectWithDefinedKey<T extends string>(\n  value: unknown,\n  key: T,\n): value is { [K in T]: Exclude<unknown, undefined> } {\n  if (!isObject(value)) {\n    return false;\n  }\n  const candidate = value as Record<string, unknown>;\n  if (!(key in candidate)) {\n    return false;\n  }\n  return candidate[key] !== undefined;\n}\n\n/**\n * Checks if a value is an object with a specific key and value.\n * @param value - The value to check.\n * @param key - The key to check for.\n * @param expectedValue - The expected value for the key.\n * @returns True if the value is an object with the key and value, false otherwise.\n */\nexport function objectWithKeyAndValue<T extends string, V>(\n  value: unknown,\n  key: T,\n  expectedValue: V,\n): value is { [K in T]: V } {\n  return objectWithKey(value, key) && value[key] === expectedValue;\n}\n\n/**\n * Checks if a value is an object with a specific key of a specific type.\n * @param value - The value to check.\n * @param key - The key to check for.\n * @param typeGuard - A type guard function to validate the value at the key.\n * @returns True if the value is an object with the key of the specified type, false otherwise.\n */\nexport function objectWithKeyOfType<T extends string, V>(\n  value: unknown,\n  key: T,\n  typeGuard: (val: unknown) => val is V,\n): value is { [K in T]: V } {\n  return objectWithKey(value, key) && typeGuard(value[key]);\n}\n\nexport function isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n\nexport function isNumber(value: unknown): value is number {\n  return typeof value === \"number\";\n}\n\nexport function errorToResponse(\n  err: unknown,\n  requestId: JsonRpcId | undefined,\n): JsonRpcRes | null {\n  if (requestId === undefined) {\n    return null;\n  }\n\n  if (err instanceof RpcError) {\n    return createJsonRpcError(requestId, err.toJson());\n  }\n\n  const errorData =\n    err instanceof Error ? { message: err.message, stack: err.stack } : err;\n\n  return createJsonRpcError(\n    requestId,\n    new RpcError(\n      JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n      \"Internal error\",\n      errorData,\n    ).toJson(),\n  );\n}\n", "import type { StandardSchemaV1 } from \"@standard-schema/spec\";\nimport type { AuthInfo } from \"./auth.js\";\nimport { GLOBAL_NOTIFICATIONS, JSON_RPC_VERSION } from \"./constants.js\";\nimport type { UriMatcher } from \"./uri-template.js\";\nimport {\n  isNumber,\n  isObject,\n  isString,\n  objectWithDefinedKey,\n  objectWithKeyAndValue,\n  objectWithKeyOfType,\n} from \"./utils.js\";\n\nexport const JSON_RPC_ERROR_CODES = {\n  PARSE_ERROR: -32700,\n  INVALID_REQUEST: -32600,\n  METHOD_NOT_FOUND: -32601,\n  INVALID_PARAMS: -32602,\n  INTERNAL_ERROR: -32603,\n} as const;\n\nexport type JsonRpcStandardErrorCode =\n  (typeof JSON_RPC_ERROR_CODES)[keyof typeof JSON_RPC_ERROR_CODES];\n\nexport type JsonRpcId = string | null;\n\nexport interface JsonRpcReq {\n  jsonrpc: typeof JSON_RPC_VERSION;\n  id: JsonRpcId;\n  method: string;\n  params?: unknown;\n}\n\nexport interface JsonRpcNotification {\n  jsonrpc: typeof JSON_RPC_VERSION;\n  method: string;\n  params?: unknown;\n}\n\nexport type JsonRpcMessage = JsonRpcReq | JsonRpcNotification;\n\nexport interface JsonRpcRes {\n  jsonrpc: typeof JSON_RPC_VERSION;\n  id: JsonRpcId;\n  result?: unknown;\n  error?: JsonRpcError;\n}\n\nexport interface JsonRpcError {\n  code: number;\n  message: string;\n  data?: unknown;\n}\n\nexport type OnError = (\n  err: unknown,\n  ctx: MCPServerContext,\n) => JsonRpcError | undefined | Promise<JsonRpcError | undefined>;\n\nexport interface InitializeParams {\n  protocolVersion: string;\n  capabilities?: {\n    elicitation?: Record<string, never>;\n    [key: string]: unknown;\n  };\n  clientInfo?: {\n    name: string;\n    version: string;\n  };\n}\n\nexport interface InitializeResult {\n  protocolVersion: string;\n  serverInfo: {\n    name: string;\n    version: string;\n  };\n  capabilities: {\n    tools?: { listChanged?: boolean };\n    prompts?: { listChanged?: boolean };\n    resources?: { listChanged?: boolean; subscribe?: boolean };\n  };\n}\n\nexport type ProgressToken = string | number;\n\nexport interface ProgressUpdate {\n  progress: number;\n  total?: number;\n  message?: string;\n}\n\nexport interface MCPServerContext {\n  request: JsonRpcMessage;\n  requestId: JsonRpcId | undefined;\n  response: JsonRpcRes | null;\n  env: Record<string, unknown>;\n  state: Record<string, unknown>;\n  /**\n   * Info on the authenticated user, if any\n   */\n  authInfo?: AuthInfo;\n  session?: { id: string; protocolVersion: string };\n  progressToken?: ProgressToken;\n  validate<T>(validator: unknown, input: unknown): T;\n  progress?(update: ProgressUpdate): Promise<void> | void;\n  client: MCPClientFeatures;\n  elicit<S extends StandardSchemaV1<unknown, unknown>>(\n    params: { message: string; schema: S },\n    options?: { timeout_ms?: number; strict?: boolean },\n  ): Promise<ElicitationResult<StandardSchemaV1.InferInput<S>>>;\n  elicit<T = Record<string, unknown>>(\n    params: { message: string; schema: unknown },\n    options?: { timeout_ms?: number; strict?: boolean },\n  ): Promise<ElicitationResult<T>>;\n  sample(\n    params: SamplingParams,\n    options?: { timeout_ms?: number },\n  ): Promise<SamplingResult>;\n}\n\nexport interface MCPClientFeatures {\n  supports(feature: ClientCapabilities | string): boolean;\n}\n\nexport type Middleware = (\n  ctx: MCPServerContext,\n  next: () => Promise<void>,\n) => Promise<void> | void;\n\nexport type MethodHandler = (\n  params: unknown,\n  ctx: MCPServerContext,\n) => Promise<unknown> | unknown;\n\nexport function isJsonRpcNotification(\n  obj: unknown,\n): obj is JsonRpcNotification {\n  if (!isObject(obj)) {\n    return false;\n  }\n\n  const candidate = obj as Record<string, unknown>;\n\n  if (candidate.jsonrpc !== \"2.0\") {\n    return false;\n  }\n\n  if (!isString(candidate.method)) {\n    return false;\n  }\n\n  if (\"id\" in candidate) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function isJsonRpcRequest(obj: unknown): obj is JsonRpcReq {\n  if (!isObject(obj)) {\n    return false;\n  }\n\n  const candidate = obj as Record<string, unknown>;\n\n  if (candidate.jsonrpc !== \"2.0\") {\n    return false;\n  }\n\n  if (!isString(candidate.method)) {\n    return false;\n  }\n\n  if (!(\"id\" in candidate)) {\n    return false;\n  }\n\n  const id = candidate.id;\n  if (!isString(id) && !isNumber(id) && id !== null) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function isJsonRpcResponse(obj: unknown): obj is JsonRpcRes {\n  if (!isObject(obj)) {\n    return false;\n  }\n\n  const candidate = obj as Record<string, unknown>;\n\n  if (candidate.jsonrpc !== \"2.0\") {\n    return false;\n  }\n\n  if (!(\"id\" in candidate)) {\n    return false;\n  }\n\n  const id = candidate.id;\n  if (!isString(id) && !isNumber(id) && id !== null) {\n    return false;\n  }\n\n  // Must have either result or error\n  if (!(\"result\" in candidate) && !(\"error\" in candidate)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function createJsonRpcResponse(\n  id: JsonRpcId,\n  result?: unknown,\n): JsonRpcRes {\n  return {\n    jsonrpc: JSON_RPC_VERSION,\n    id,\n    result,\n  };\n}\n\nexport function createJsonRpcError(\n  id: JsonRpcId,\n  error: JsonRpcError,\n): JsonRpcRes {\n  return {\n    jsonrpc: JSON_RPC_VERSION,\n    id,\n    error,\n  };\n}\n\nexport function isInitializeParams(obj: unknown): obj is InitializeParams {\n  if (!isObject(obj)) {\n    return false;\n  }\n\n  const candidate = obj as Record<string, unknown>;\n\n  if (!objectWithKeyOfType(candidate, \"protocolVersion\", isString)) {\n    return false;\n  }\n\n  if (\n    objectWithDefinedKey(candidate, \"capabilities\") &&\n    !objectWithKeyOfType(candidate, \"capabilities\", isObject)\n  ) {\n    return false;\n  }\n\n  if (objectWithDefinedKey(candidate, \"clientInfo\")) {\n    if (!objectWithKeyOfType(candidate, \"clientInfo\", isObject)) {\n      return false;\n    }\n\n    const clientInfoObj = candidate.clientInfo as Record<string, unknown>;\n\n    if (!isClientInfo(clientInfoObj)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isClientInfo(obj: unknown) {\n  if (!objectWithKeyOfType(obj, \"name\", isString)) {\n    return false;\n  }\n  if (!objectWithKeyOfType(obj, \"version\", isString)) {\n    return false;\n  }\n  return true;\n}\n\nexport interface Tool {\n  name: string;\n  description?: string;\n  inputSchema: unknown;\n  outputSchema?: unknown;\n  title?: string;\n  _meta?: { [key: string]: unknown };\n}\n\nexport interface Prompt {\n  name: string;\n  description?: string;\n  arguments?: unknown[];\n  title?: string;\n  _meta?: { [key: string]: unknown };\n}\n\nexport interface PromptArgumentDef {\n  name: string;\n  description?: string;\n  required?: boolean;\n}\n\nexport interface PromptMetadata {\n  name: string;\n  title?: string;\n  description?: string;\n  arguments?: PromptArgumentDef[];\n  _meta?: { [key: string]: unknown };\n}\n\nexport type PromptHandler<TArgs = unknown> = (\n  args: TArgs,\n  ctx: MCPServerContext,\n) => Promise<PromptGetResult> | PromptGetResult;\n\nexport interface PromptEntry {\n  metadata: PromptMetadata;\n  handler: PromptHandler;\n  validator?: unknown;\n}\n\nexport interface Resource {\n  uri: string;\n  name?: string;\n  description?: string;\n  mimeType?: string;\n  _meta?: { [key: string]: unknown };\n  annotations?: Annotations;\n}\n\nexport interface ResourceProvider {\n  list?: (ctx: MCPServerContext) => unknown;\n  read?: (uri: string, ctx: MCPServerContext) => unknown;\n  subscribe?: (\n    uri: string,\n    ctx: MCPServerContext,\n    onChange: (n: { uri: string }) => void,\n  ) => unknown;\n}\n\nexport interface ToolEntry {\n  metadata: Tool;\n  handler: MethodHandler;\n  validator?: unknown;\n  outputValidator?: unknown;\n}\n\nexport interface ResourceEntry {\n  metadata: Resource | ResourceTemplate;\n  handler: ResourceHandler;\n  validators?: ResourceVarValidators;\n  matcher?: UriMatcher;\n  type: \"resource\" | \"resource_template\";\n}\n\nexport type InferInput<T> = T extends StandardSchemaV1<unknown, unknown>\n  ? StandardSchemaV1.InferInput<T>\n  : unknown;\n\nexport type InferOutput<T> = T extends StandardSchemaV1<unknown, unknown>\n  ? StandardSchemaV1.InferOutput<T>\n  : unknown;\n\nexport type SchemaAdapter = (schema: StandardSchemaV1) => JsonSchema;\nexport type JsonSchema = unknown;\n\nexport function isStandardSchema(value: unknown): value is StandardSchemaV1 {\n  return (\n    value !== null &&\n    // ArkType uses functions for schemas, so we need to check whether `value` is an object or a function\n    (typeof value === \"object\" || typeof value === \"function\") &&\n    \"~standard\" in value &&\n    typeof (value as Record<string, unknown>)[\"~standard\"] === \"object\" &&\n    (value as { \"~standard\": { version: number } })[\"~standard\"].version === 1\n  );\n}\n\nexport type Role = \"user\" | \"assistant\" | \"system\";\n\nexport type ClientCapabilities = \"elicitation\" | \"roots\" | \"sampling\";\n\nexport interface Annotations {\n  audience?: Role[];\n  lastModified?: string;\n  priority?: number;\n}\n\nexport type TextResourceContents = {\n  _meta?: { [key: string]: unknown };\n  uri: string;\n  type: \"text\";\n  text: string;\n  mimeType?: string;\n};\n\nexport type BlobResourceContents = {\n  _meta?: { [key: string]: unknown };\n  uri: string;\n  blob: string;\n  mimeType?: string;\n};\n\nexport type ResourceContents = TextResourceContents | BlobResourceContents;\n\ninterface MetaAnnotated {\n  _meta?: { [key: string]: unknown };\n  annotations?: Annotations;\n}\n\ninterface TextContent extends MetaAnnotated {\n  type: \"text\";\n  text: string;\n}\n\ninterface ImageContent extends MetaAnnotated {\n  type: \"image\";\n  data: string;\n  mimeType: string;\n}\n\ninterface AudioContent extends MetaAnnotated {\n  type: \"audio\";\n  data: string;\n  mimeType: string;\n}\n\ninterface ResourceLink extends MetaAnnotated {\n  type: \"resource_link\";\n  uri: string;\n}\n\ninterface EmbeddedResource extends MetaAnnotated {\n  type: \"resource\";\n  resource: ResourceContents;\n}\n\nexport type Content =\n  | TextContent\n  | ImageContent\n  | AudioContent\n  | ResourceLink\n  | EmbeddedResource;\n\nexport interface PromptGetParams {\n  name: string;\n  arguments?: unknown;\n}\n\nexport interface ResourceReadParams {\n  uri: string;\n}\n\nexport interface ResourceSubscribeParams {\n  uri: string;\n}\n\nexport interface ToolCallResult<TStructuredContent = unknown> {\n  content: Content[];\n  isError?: boolean;\n  structuredContent?: TStructuredContent;\n  _meta?: { [key: string]: unknown };\n}\n\nexport interface PromptGetResult {\n  description?: string;\n  messages: unknown[];\n  _meta?: { [key: string]: unknown };\n}\n\nexport interface ResourceReadResult {\n  contents: ResourceContents[];\n  _meta?: { [key: string]: unknown };\n}\n\nexport interface ListToolsResult {\n  tools: Tool[];\n  _meta?: { [key: string]: unknown };\n}\n\nexport interface ListPromptsResult {\n  prompts: Prompt[];\n  _meta?: { [key: string]: unknown };\n}\n\nexport interface ListResourcesResult {\n  resources: Resource[];\n  _meta?: { [key: string]: unknown };\n}\n\nexport interface ListResourceTemplatesResult {\n  resourceTemplates: ResourceTemplate[];\n  _meta?: { [key: string]: unknown };\n}\n\nexport interface ResourceTemplate {\n  uriTemplate: string;\n  name?: string;\n  description?: string;\n  mimeType?: string;\n  _meta?: { [key: string]: unknown };\n  annotations?: Annotations;\n}\n\nexport type ResourceVars = Record<string, string>;\n\nexport interface ResourceMeta {\n  name?: string;\n  description?: string;\n  mimeType?: string;\n  _meta?: { [key: string]: unknown };\n  annotations?: Annotations;\n}\n\nexport type ResourceVarValidators = Record<string, unknown>;\n\nexport type ResourceHandler = (\n  uri: URL,\n  vars: ResourceVars,\n  ctx: MCPServerContext,\n) => Promise<ResourceReadResult>;\n\nexport interface NotificationSenderOptions {\n  relatedRequestId?: string;\n}\n\nexport type NotificationSender = (\n  sessionId: string | undefined,\n  notification: { method: string; params?: unknown },\n  options?: NotificationSenderOptions,\n) => Promise<void> | void;\n\ntype GlobalNotification = (typeof GLOBAL_NOTIFICATIONS)[number];\n\nexport function isGlobalNotification(\n  notificationMethod: string,\n): notificationMethod is GlobalNotification {\n  for (const globalNotification of GLOBAL_NOTIFICATIONS) {\n    if (notificationMethod === globalNotification) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport type ElicitationAction = \"accept\" | \"decline\" | \"cancel\";\n\nexport interface ElicitationResult<TContent = Record<string, unknown>> {\n  action: ElicitationAction;\n  content?: TContent; // present on \"accept\"\n}\n\nexport type SamplingParams = {\n  /** Prompt to forward to the llm for generation */\n  prompt: string; // TODO - Support a messages array as indicated in the spec?\n  /** The system prompt to give the LLM */\n  systemPrompt?: string;\n  /** The maximum number of tokens the LLM should generate */\n  maxTokens?: number;\n  /** Preference hints for the client when forwarding request to LLM - note that the mcp client makes final decision on model selection */\n  modelPreferences?: {\n    /** A hint of which model to use, e.g., \"claude\" would allow any model from the claude fam */\n    hints?: Array<{ name: string }>;\n    /** A number 0-1, where 1 prefers more intelligent models */\n    intelligencePriority?: number;\n    /** A number 0-1, where 1 prefers faster models */\n    speedPriority?: number;\n    /** A number 0-1, where 1 prefers cheaper models */\n    costPriority?: number;\n  };\n};\n\ntype SamplingTextContent = {\n  type: \"text\";\n  text: string;\n};\n\ntype SamplingImageContent = {\n  type: \"image\";\n  /** base64 encoded image data */\n  data: string;\n  /** mimetype of the image (e.g., \"image/jpeg\") */\n  mimeType?: string;\n};\n\ntype SamplingAudioContent = {\n  type: \"audio\";\n  /** base64 encoded audio data */\n  data: string;\n  /** mimetype of the audio (e.g., \"audio/wav\") */\n  mimeType?: string;\n};\n\n/**\n * @see https://modelcontextprotocol.io/specification/2025-06-18/schema#createmessageresult\n */\nexport type SamplingResult = {\n  role: \"assistant\";\n  content: SamplingTextContent | SamplingImageContent | SamplingAudioContent;\n  model: string;\n  /** @example - \"endTurn\" */\n  stopReason?: string;\n};\n\n/**\n * Type guard for a sampling result\n *\n * @note - This only verifies the content property.\n *         Since sampling is so loosely specified, and very few clients implement it,\n *        it seems best to only validate the bare minimum here\n */\nexport function isSamplingResult(o: unknown): o is SamplingResult {\n  return objectWithKeyOfType(o, \"content\", isSamplingContent);\n}\n\nfunction isSamplingContent(o: unknown): o is SamplingResult[\"content\"] {\n  return (\n    isSamplingTextContent(o) ||\n    isSamplingImageContent(o) ||\n    isSamplingAudioContent(o)\n  );\n}\n\nfunction isSamplingTextContent(o: unknown): o is SamplingTextContent {\n  return (\n    objectWithKeyAndValue(o, \"type\", \"text\") &&\n    objectWithKeyOfType(o, \"text\", isString)\n  );\n}\n\nfunction isSamplingImageContent(o: unknown): o is SamplingImageContent {\n  return (\n    objectWithKeyAndValue(o, \"type\", \"image\") &&\n    objectWithKeyOfType(o, \"data\", isString)\n  );\n}\n\nfunction isSamplingAudioContent(o: unknown): o is SamplingAudioContent {\n  return (\n    objectWithKeyAndValue(o, \"type\", \"audio\") &&\n    objectWithKeyOfType(o, \"data\", isString)\n  );\n}\n", "import { RpcError } from \"./errors.js\";\nimport type { PromptArgumentDef, SchemaAdapter } from \"./types.js\";\nimport { isStandardSchema, JSON_RPC_ERROR_CODES } from \"./types.js\";\n\nexport function resolveSchema(\n  schema?: unknown,\n  schemaAdapter?: SchemaAdapter,\n): {\n  resolvedSchema: unknown;\n  validator?: unknown;\n} {\n  if (!schema) return { resolvedSchema: { type: \"object\" } };\n\n  if (isStandardSchema(schema)) {\n    if (!schemaAdapter) {\n      const vendor = schema[\"~standard\"].vendor;\n      throw new Error(\n        `Cannot use Standard Schema (vendor: \"${vendor}\") without a schema adapter. ` +\n          `Configure a schema adapter when creating McpServer.`,\n      );\n    }\n\n    const jsonSchema = schemaAdapter(schema);\n    return { resolvedSchema: jsonSchema, validator: schema };\n  }\n\n  return { resolvedSchema: schema };\n}\n\nexport function createValidationFunction<T>(\n  validator: unknown,\n  input: unknown,\n): T {\n  if (isStandardSchema(validator)) {\n    const result = validator[\"~standard\"].validate(input);\n    if (result instanceof Promise) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        \"Async validation not supported in this context\",\n      );\n    }\n    if (\"issues\" in result && result.issues?.length) {\n      const messages = result.issues.map((i) => i.message).join(\", \");\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        `Validation failed: ${messages}`,\n      );\n    }\n    return (result as { value: T }).value;\n  }\n\n  if (validator && typeof validator === \"object\" && \"validate\" in validator) {\n    const validatorObj = validator as {\n      validate(input: unknown): {\n        ok: boolean;\n        data?: unknown;\n        issues?: unknown[];\n      };\n    };\n    const result = validatorObj.validate(input);\n    if (result?.ok && result.data !== undefined) {\n      return result.data as T;\n    }\n    throw new RpcError(\n      JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n      \"Validation failed\",\n    );\n  }\n\n  throw new RpcError(JSON_RPC_ERROR_CODES.INVALID_PARAMS, \"Invalid validator\");\n}\n\nexport function extractArgumentsFromSchema(\n  schema: unknown,\n): PromptArgumentDef[] {\n  if (!schema || typeof schema !== \"object\") {\n    return [];\n  }\n\n  const schemaObj = schema as Record<string, unknown>;\n\n  if (schemaObj.type === \"object\" && schemaObj.properties) {\n    const properties = schemaObj.properties as Record<string, unknown>;\n    const required = (schemaObj.required as string[]) || [];\n\n    return Object.entries(properties).map(([name, propSchema]) => {\n      const prop = propSchema as Record<string, unknown>;\n      return {\n        name,\n        description: prop.description as string | undefined,\n        required: required.includes(name),\n      };\n    });\n  }\n\n  return [];\n}\n\ninterface ElicitationJsonSchema {\n  type: \"object\";\n  properties: Record<string, unknown>;\n  required?: string[];\n  additionalProperties?: boolean;\n}\n\nexport function toElicitationRequestedSchema(\n  schema: unknown,\n  strict = false,\n): ElicitationJsonSchema {\n  // Handle Standard Schema inputs by converting to JSON Schema first\n  if (isStandardSchema(schema)) {\n    throw new Error(\n      \"Standard Schema inputs must be converted via resolveSchema first\",\n    );\n  }\n\n  if (!schema || typeof schema !== \"object\") {\n    if (strict) {\n      throw new Error(\"Schema must be an object\");\n    }\n    return { type: \"object\", properties: {} };\n  }\n\n  const schemaObj = schema as Record<string, unknown>;\n\n  // Ensure root is object type\n  if (schemaObj.type !== \"object\") {\n    if (strict) {\n      throw new Error(\"Root schema must be of type 'object'\");\n    }\n    return { type: \"object\", properties: {} };\n  }\n\n  if (!schemaObj.properties || typeof schemaObj.properties !== \"object\") {\n    if (strict) {\n      throw new Error(\"Object schema must have properties\");\n    }\n    return { type: \"object\", properties: {} };\n  }\n\n  const properties = schemaObj.properties as Record<string, unknown>;\n  const requiredArray = Array.isArray(schemaObj.required)\n    ? (schemaObj.required as string[])\n    : [];\n\n  const elicitationProperties: Record<string, unknown> = {};\n  const validRequired: string[] = [];\n\n  for (const [propName, propSchema] of Object.entries(properties)) {\n    const projectedProp = projectPropertyToElicitation(propSchema, strict);\n    if (projectedProp !== null) {\n      elicitationProperties[propName] = projectedProp;\n      if (requiredArray.includes(propName)) {\n        validRequired.push(propName);\n      }\n    }\n  }\n\n  const result: ElicitationJsonSchema = {\n    type: \"object\",\n    properties: elicitationProperties,\n  };\n\n  if (validRequired.length > 0) {\n    result.required = validRequired;\n  }\n\n  return result;\n}\n\nfunction projectPropertyToElicitation(\n  propSchema: unknown,\n  strict: boolean,\n): unknown | null {\n  if (!propSchema || typeof propSchema !== \"object\") {\n    if (strict) {\n      throw new Error(\"Property schema must be an object\");\n    }\n    return null;\n  }\n\n  const prop = propSchema as Record<string, unknown>;\n  const propType = prop.type;\n\n  // Handle primitive types\n  if (\n    propType === \"string\" ||\n    propType === \"number\" ||\n    propType === \"integer\" ||\n    propType === \"boolean\"\n  ) {\n    const result: Record<string, unknown> = { type: propType };\n\n    // Preserve description\n    if (typeof prop.description === \"string\") {\n      result.description = prop.description;\n    }\n\n    // Preserve default\n    if (prop.default !== undefined) {\n      result.default = prop.default;\n    }\n\n    // Handle string-specific properties\n    if (propType === \"string\") {\n      // Preserve string constraints\n      if (typeof prop.minLength === \"number\") {\n        result.minLength = prop.minLength;\n      }\n      if (typeof prop.maxLength === \"number\") {\n        result.maxLength = prop.maxLength;\n      }\n\n      // Handle string format (only supported ones)\n      if (typeof prop.format === \"string\") {\n        const supportedFormats = [\"email\", \"uri\", \"date\", \"date-time\"];\n        if (supportedFormats.includes(prop.format)) {\n          result.format = prop.format;\n        } else if (strict) {\n          throw new Error(`Unsupported string format: ${prop.format}`);\n        }\n      }\n\n      // Handle string enums with enumNames\n      if (Array.isArray(prop.enum)) {\n        const enumValues = prop.enum;\n        const enumNames = Array.isArray(prop.enumNames)\n          ? (prop.enumNames as string[])\n          : undefined;\n\n        // Only include if all enum values are strings\n        if (enumValues.every((val) => typeof val === \"string\")) {\n          result.enum = enumValues;\n          if (enumNames && enumNames.length === enumValues.length) {\n            result.enumNames = enumNames;\n          }\n        } else if (strict) {\n          throw new Error(\"Enum values must be strings for elicitation\");\n        }\n      }\n    }\n\n    // Handle number/integer constraints\n    if (propType === \"number\" || propType === \"integer\") {\n      if (typeof prop.minimum === \"number\") {\n        result.minimum = prop.minimum;\n      }\n      if (typeof prop.maximum === \"number\") {\n        result.maximum = prop.maximum;\n      }\n    }\n\n    return result;\n  }\n\n  // Drop unsupported types (arrays, objects, etc.)\n  if (strict) {\n    throw new Error(`Unsupported property type: ${propType}`);\n  }\n\n  return null;\n}\n", "import type { AuthInfo } from \"./auth.js\";\nimport { METHODS, SUPPORTED_MCP_PROTOCOL_VERSIONS } from \"./constants.js\";\nimport { RpcError } from \"./errors.js\";\nimport type {\n  ElicitationResult,\n  JsonRpcId,\n  JsonRpcMessage,\n  JsonRpcReq,\n  JsonRpcRes,\n  MCPServerContext,\n  ProgressToken,\n  ProgressUpdate,\n  SamplingParams,\n  SamplingResult,\n  SchemaAdapter,\n} from \"./types.js\";\nimport { isSamplingResult, JSON_RPC_ERROR_CODES } from \"./types.js\";\nimport { isObject, objectWithKey } from \"./utils.js\";\nimport {\n  createValidationFunction,\n  resolveSchema,\n  toElicitationRequestedSchema,\n} from \"./validation.js\";\n\nexport interface CreateContextOptions {\n  sessionId?: string;\n  sessionProtocolVersion?: string;\n  progressToken?: ProgressToken;\n  progressSender?: (update: ProgressUpdate) => Promise<void> | void;\n  authInfo?: AuthInfo;\n  clientCapabilities?: {\n    elicitation?: Record<string, never>;\n    roots?: Record<string, never>;\n    sampling?: Record<string, never>;\n    [key: string]: unknown;\n  };\n\n  // Add these for elicit implementation\n  schemaAdapter?: SchemaAdapter;\n  clientRequestSender?: (\n    sessionId: string | undefined,\n    request: JsonRpcReq,\n    options?: { relatedRequestId?: string | number; timeout_ms?: number },\n  ) => Promise<JsonRpcRes>;\n}\n\n/**\n * Extract progress token from a JSON-RPC message.\n */\nexport function getProgressToken(\n  message: JsonRpcMessage,\n): ProgressToken | undefined {\n  if (isObject(message.params)) {\n    const params = message.params as Record<string, unknown>;\n    const meta = params._meta as Record<string, unknown> | undefined;\n    if (objectWithKey(meta, \"progressToken\")) {\n      return meta.progressToken as ProgressToken;\n    }\n  }\n  return undefined;\n}\n\nexport function createContext(\n  message: JsonRpcMessage,\n  requestId: JsonRpcId | undefined,\n  options: CreateContextOptions = {},\n): MCPServerContext {\n  // Prefer explicit option, otherwise derive from the request message\n  const progressToken =\n    options.progressToken !== undefined\n      ? options.progressToken\n      : getProgressToken(message);\n\n  const context: MCPServerContext = {\n    request: message,\n    authInfo: options.authInfo,\n    requestId,\n    response: null,\n    env: {},\n    state: {},\n    progressToken,\n    validate: <T>(validator: unknown, input: unknown): T =>\n      createValidationFunction<T>(validator, input),\n    client: {\n      supports: (\n        feature: \"elicitation\" | \"roots\" | \"sampling\" | string,\n      ): boolean => {\n        // Real implementation will be injected in _dispatch if capabilities are available\n        if (options.clientCapabilities) {\n          return feature in options.clientCapabilities;\n        }\n        return false;\n      },\n    },\n    elicit: async (\n      params: { message: string; schema: unknown },\n      elicitOptions?: { timeout_ms?: number; strict?: boolean },\n    ): Promise<ElicitationResult> => {\n      // 1. Guard: check elicitation support\n      if (!context.client.supports(\"elicitation\")) {\n        throw new RpcError(\n          JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND,\n          \"Elicitation not supported by client\",\n        );\n      }\n\n      // 2. Convert schema to JSON Schema if needed\n      const { resolvedSchema } = resolveSchema(\n        params.schema,\n        options.schemaAdapter,\n      );\n\n      // 3. Project to elicitation-compatible schema\n      const requestedSchema = toElicitationRequestedSchema(\n        resolvedSchema,\n        elicitOptions?.strict,\n      );\n\n      // 4. Build JSON-RPC request\n      const elicitRequest: JsonRpcReq = {\n        jsonrpc: \"2.0\",\n        id: Math.random().toString(36).substring(7),\n        method: METHODS.ELICITATION.CREATE,\n        params: {\n          message: params.message,\n          requestedSchema,\n        },\n      };\n\n      // 5. Send request to client\n      if (!options.clientRequestSender) {\n        throw new RpcError(\n          JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n          \"Client request sender not configured\",\n        );\n      }\n\n      const response = await options.clientRequestSender(\n        context.session?.id,\n        elicitRequest,\n        {\n          relatedRequestId: requestId as string | number,\n          timeout_ms: elicitOptions?.timeout_ms,\n        },\n      );\n\n      // 6. Validate and return response\n      if (response.error) {\n        throw new RpcError(\n          response.error.code,\n          response.error.message,\n          response.error.data,\n        );\n      }\n\n      return response.result as ElicitationResult;\n    },\n    sample: async (\n      params: SamplingParams,\n      sampleOptions?: { timeout_ms: number },\n    ): Promise<SamplingResult> => {\n      // 1. Guard: check sampling support\n      if (!context.client.supports(\"sampling\")) {\n        throw new RpcError(\n          JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND,\n          \"Sampling not supported by client\",\n        );\n      }\n\n      // 2. Build JSON-RPC request\n      const samplingRequest: JsonRpcReq = {\n        jsonrpc: \"2.0\",\n        id: Math.random().toString(36).substring(7),\n        method: METHODS.SAMPLING.CREATE,\n        params: {\n          messages: [\n            {\n              role: \"user\",\n              content: {\n                type: \"text\",\n                text: params.prompt,\n              },\n            },\n          ],\n          modelPreferences: params.modelPreferences,\n          systemPrompt: params.systemPrompt,\n          maxTokens: params.maxTokens,\n        },\n      };\n\n      // 3. Send request to client\n      if (!options.clientRequestSender) {\n        throw new RpcError(\n          JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n          \"Client request sender not configured\",\n        );\n      }\n\n      const response = await options.clientRequestSender(\n        context.session?.id,\n        samplingRequest,\n        {\n          relatedRequestId: requestId as string | number,\n          timeout_ms: sampleOptions?.timeout_ms,\n        },\n      );\n\n      // 4. Validate and return response\n      if (response.error) {\n        throw new RpcError(\n          response.error.code,\n          response.error.message,\n          response.error.data,\n        );\n      }\n\n      if (!isSamplingResult(response.result)) {\n        // TODO - use logger once we put it on context\n        console.error(\n          \"Unexpected sampling response format from client\",\n          JSON.stringify(response.result, null, 2),\n        );\n        // TODO - Tighten up this RPC Error\n        throw new RpcError(\n          -32602, // Invalid params (investigate another error code)\n          \"Unexpected sampling response format from client\",\n        );\n      }\n\n      return response.result;\n    },\n  };\n\n  if (progressToken && options.progressSender) {\n    context.progress = async (update: ProgressUpdate): Promise<void> => {\n      await options.progressSender?.(update);\n    };\n  }\n\n  if (options.sessionId) {\n    context.session = {\n      id: options.sessionId,\n      protocolVersion:\n        options.sessionProtocolVersion ||\n        SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_03_26,\n    };\n  }\n\n  return context;\n}\n", "import type { ResourceVars } from \"./types.js\";\n\nexport interface UriMatcher {\n  match: (uri: string) => ResourceVars | null;\n  type: \"resource\" | \"resource_template\";\n}\n\n/**\n * Compiles a URI template into a matcher function.\n * Supports Hono-style path parameters: {name}, {name*}, and query groups {?a,b,c}\n */\nexport function compileUriTemplate(template: string): UriMatcher {\n  const isStatic = !template.includes(\"{\");\n\n  if (isStatic) {\n    return {\n      match: (uri: string) => (uri === template ? {} : null),\n      type: \"resource\",\n    };\n  }\n\n  // Extract query parameter group if present: {?param1,param2}\n  const queryMatch = template.match(/\\{\\?([^}]+)\\}/);\n  const queryParams = queryMatch?.[1]\n    ? queryMatch[1].split(\",\").map((p) => p.trim())\n    : [];\n\n  // Remove query group from template for path matching\n  const pathTemplate = template.replace(/\\{\\?[^}]+\\}/, \"\");\n\n  // Convert path template to regex\n  // Escape special regex characters except our placeholders\n  let escapedTemplate = pathTemplate.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n\n  // Convert placeholders to regex groups\n  escapedTemplate = escapedTemplate\n    .replace(/\\\\{([^}*]+)\\\\*\\\\}/g, \"(?<$1>.*)\") // {name*} -> greedy capture\n    .replace(/\\\\{([^}]+)\\\\}/g, \"(?<$1>[^/?]+)\"); // {name} -> non-greedy capture (allow query params)\n\n  const regex = new RegExp(`^${escapedTemplate}$`);\n\n  return {\n    match: (uri: string) => {\n      try {\n        // For templates with query params, match against the path part only\n        const [pathPart] = uri.split(\"?\");\n        const matchTarget = queryParams.length > 0 ? (pathPart ?? uri) : uri;\n\n        const pathMatch = matchTarget.match(regex);\n\n        if (!pathMatch) return null;\n\n        const vars: ResourceVars = { ...pathMatch.groups };\n\n        // Extract query parameters if specified in template\n        if (queryParams.length > 0) {\n          try {\n            const url = new URL(uri);\n            for (const param of queryParams) {\n              const value = url.searchParams.get(param);\n              if (value !== null) {\n                vars[param] = value;\n              }\n            }\n          } catch {\n            // If URL parsing fails, skip query params extraction\n          }\n        }\n\n        return vars;\n      } catch {\n        return null;\n      }\n    },\n    type: \"resource_template\",\n  };\n}\n", "import type { StandardSchemaV1 } from \"@standard-schema/spec\";\nimport {\n  METHODS,\n  SUPPORTED_MCP_PROTOCOL_VERSIONS,\n  SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST,\n} from \"./constants.js\";\nimport {\n  type CreateContextOptions,\n  createContext,\n  getProgressToken,\n} from \"./context.js\";\nimport { RpcError } from \"./errors.js\";\nimport type {\n  InferOutput,\n  InitializeResult,\n  JsonRpcMessage,\n  JsonRpcNotification,\n  JsonRpcReq,\n  JsonRpcRes,\n  ListPromptsResult,\n  ListResourcesResult,\n  ListResourceTemplatesResult,\n  ListToolsResult,\n  MCPServerContext,\n  MethodHandler,\n  Middleware,\n  OnError,\n  PromptArgumentDef,\n  PromptEntry,\n  PromptGetResult,\n  PromptHandler,\n  PromptMetadata,\n  Resource,\n  ResourceEntry,\n  ResourceHandler,\n  ResourceMeta,\n  ResourceReadResult,\n  ResourceTemplate,\n  ResourceVarValidators,\n  SchemaAdapter,\n  Tool,\n  ToolCallResult,\n  ToolEntry,\n} from \"./types.js\";\nimport {\n  createJsonRpcError,\n  createJsonRpcResponse,\n  isInitializeParams,\n  isJsonRpcNotification,\n  JSON_RPC_ERROR_CODES,\n} from \"./types.js\";\nimport { compileUriTemplate } from \"./uri-template.js\";\nimport { errorToResponse, isObject, isString } from \"./utils.js\";\nimport {\n  createValidationFunction,\n  extractArgumentsFromSchema,\n  resolveSchema,\n} from \"./validation.js\";\n\ntype SupportedVersion =\n  (typeof SUPPORTED_MCP_PROTOCOL_VERSIONS)[keyof typeof SUPPORTED_MCP_PROTOCOL_VERSIONS];\n\nfunction isSupportedVersion(version: string): version is SupportedVersion {\n  return SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST.includes(\n    version as SupportedVersion,\n  );\n}\n\nasync function runMiddlewares(\n  middlewares: Middleware[],\n  ctx: MCPServerContext,\n  tail: () => Promise<void>,\n): Promise<void> {\n  const dispatch = async (i: number): Promise<void> => {\n    if (i < middlewares.length) {\n      const middleware = middlewares[i];\n      if (middleware) {\n        await middleware(ctx, () => dispatch(i + 1));\n      } else {\n        await dispatch(i + 1);\n      }\n    } else {\n      await tail();\n    }\n  };\n  await dispatch(0);\n}\n\n/**\n * Logger interface for MCP server internal logging.\n * Defaults to console if not provided.\n */\nexport interface Logger {\n  error(message: string, ...args: unknown[]): void;\n  warn(message: string, ...args: unknown[]): void;\n  info(message: string, ...args: unknown[]): void;\n  debug(message: string, ...args: unknown[]): void;\n}\n\nexport interface McpServerOptions {\n  name: string;\n  version: string;\n  /**\n   * A function that converts a StandardSchema to a JSON Schema\n   *\n   * In practice, you will need to coerce the `schema` parameter of this function to the correct type for the library you are using,\n   * in order to pass it to a helper that handles converting to JSON Schema.\n   *\n   * @example Using Zod\n   * ```typescript\n   * import { z } from \"zod\";\n   *\n   * const server = new McpServer({\n   *   // ...\n   *   schemaAdapter: (schema) => z.toJSONSchema(schema as z.ZodType),\n   * });\n   * ```\n   */\n  schemaAdapter?: SchemaAdapter;\n  /**\n   * Logger for internal server messages.\n   * Defaults to console if not provided.\n   *\n   * @example Using a custom logger\n   * ```typescript\n   * const server = new McpServer({\n   *   name: \"my-server\",\n   *   version: \"1.0.0\",\n   *   logger: {\n   *     error: (msg, ...args) => myLogger.error(msg, ...args),\n   *     warn: (msg, ...args) => myLogger.warn(msg, ...args),\n   *     info: (msg, ...args) => myLogger.info(msg, ...args),\n   *     debug: (msg, ...args) => myLogger.debug(msg, ...args),\n   *   }\n   * });\n   * ```\n   *\n   * @example Disabling logs\n   * ```typescript\n   * const server = new McpServer({\n   *   name: \"my-server\",\n   *   version: \"1.0.0\",\n   *   logger: {\n   *     error: () => {},\n   *     warn: () => {},\n   *     info: () => {},\n   *     debug: () => {},\n   *   }\n   * });\n   * ```\n   */\n  logger?: Logger;\n}\n\n/**\n * MCP (Model Context Protocol) Server implementation.\n *\n * Provides a framework for building MCP-compliant servers that can expose tools, prompts,\n * and resources to MCP clients. The server handles JSON-RPC 2.0 communication and protocol\n * negotiation according to the MCP specification.\n *\n * @example Basic server setup\n * ```typescript\n * import { McpServer, StreamableHttpTransport } from \"mcp-lite\";\n *\n * // Create server instance\n * const server = new McpServer({\n *   name: \"my-server\",\n *   version: \"1.0.0\"\n * });\n *\n * // Add a tool\n * server.tool(\"echo\", {\n *   description: \"Echoes the input message\",\n *   inputSchema: {\n *     type: \"object\",\n *     properties: {\n *       message: { type: \"string\" }\n *     },\n *     required: [\"message\"]\n *   },\n *   handler: (args: { message: string }) => ({\n *     content: [{ type: \"text\", text: args.message }]\n *   })\n * });\n *\n * // Create HTTP transport and bind server\n * const transport = new StreamableHttpTransport();\n * const httpHandler = transport.bind(server);\n *\n * // Use with your HTTP framework\n * app.post(\"/mcp\", async (req) => {\n *   const response = await httpHandler(req);\n *   return response;\n * });\n * ```\n *\n * @example Using middleware\n * ```typescript\n * server.use(async (ctx, next) => {\n *   console.log(\"Request:\", ctx.request.method);\n *   await next();\n *   console.log(\"Response:\", ctx.response?.result);\n * });\n * ```\n *\n * @example Tool with Standard Schema validation (Zod, Valibot, etc.)\n * ```typescript\n * import { z } from \"zod\";\n *\n * const inputSchema = z.object({\n *   value: z.number()\n * });\n *\n * server.tool(\"double\", {\n *   description: \"Doubles a number\",\n *   inputSchema, // Standard Schema validator\n *   handler: (args: { value: number }) => ({\n *     content: [{ type: \"text\", text: String(args.value * 2) }]\n *   })\n * });\n * ```\n *\n * @example Error handling\n * ```typescript\n * server.onError((error, ctx) => {\n *   console.error(\"Error in request:\", ctx.requestId, error);\n *   return {\n *     code: -32000,\n *     message: \"Custom error message\",\n *     data: { requestId: ctx.requestId }\n *   };\n * });\n * ```\n *\n * ## Core Features\n *\n * ### Tools\n * Tools are functions that can be called by MCP clients. They must return content in the\n * `ToolCallResult` format with a `content` array.\n *\n * ### Input Validation\n * - **JSON Schema**: Standard JSON Schema objects for validation\n * - **Standard Schema**: Support for Zod, Valibot, and other Standard Schema validators\n * - **No Schema**: Basic object validation when no schema provided\n *\n * ### Middleware Support\n * Middleware functions run before request handlers and can modify context, add logging,\n * implement authentication, etc.\n *\n * ### Transport Agnostic\n * The server core is transport-agnostic. Use `StreamableHttpTransport` for HTTP/REST\n * or implement custom transports for WebSockets, stdio, etc.\n *\n * ### Protocol Compliance\n * - Full MCP specification compliance\n * - JSON-RPC 2.0 protocol support\n * - Protocol version negotiation\n * - Proper error codes and messages\n *\n * @see {@link StreamableHttpTransport} For HTTP transport implementation\n * @see {@link Middleware} For middleware function signature\n * @see {@link ToolCallResult} For tool return value format\n * @see {@link MCPServerContext} For request context interface\n */\nexport class McpServer {\n  private methods: Record<string, MethodHandler> = {};\n  private initialized = false;\n  private serverInfo: { name: string; version: string };\n  private middlewares: Middleware[] = [];\n  private capabilities: InitializeResult[\"capabilities\"] = {};\n  private onErrorHandler?: OnError;\n  private schemaAdapter?: SchemaAdapter;\n  private logger: Logger;\n\n  private tools = new Map<string, ToolEntry>();\n  private prompts = new Map<string, PromptEntry>();\n  private resources = new Map<string, ResourceEntry>();\n\n  private notificationSender?: (\n    sessionId: string | undefined,\n    notification: { method: string; params?: unknown },\n    options?: { relatedRequestId?: string },\n  ) => Promise<void> | void;\n\n  private clientRequestSender?: (\n    sessionId: string | undefined,\n    request: JsonRpcReq,\n    options?: { relatedRequestId?: string | number; timeout_ms?: number },\n  ) => Promise<JsonRpcRes>;\n\n  /**\n   * Create a new MCP server instance.\n   *\n   * @param options - Server configuration options\n   * @param options.name - Server name (included in server info)\n   * @param options.version - Server version (included in server info)\n   *\n   * @example\n   * ```typescript\n   * const server = new McpServer({\n   *   name: \"my-awesome-server\",\n   *   version: \"1.2.3\"\n   * });\n   * ```\n   */\n  constructor(options: McpServerOptions) {\n    this.serverInfo = {\n      name: options.name,\n      version: options.version,\n    };\n    this.schemaAdapter = options.schemaAdapter;\n    this.logger = options.logger || console;\n\n    this.methods = {\n      [METHODS.INITIALIZE]: this.handleInitialize.bind(this),\n      [METHODS.PING]: this.handlePing.bind(this),\n      [METHODS.TOOLS.LIST]: this.handleToolsList.bind(this),\n      [METHODS.TOOLS.CALL]: this.handleToolsCall.bind(this),\n      [METHODS.PROMPTS.LIST]: this.handlePromptsList.bind(this),\n      [METHODS.PROMPTS.GET]: this.handlePromptsGet.bind(this),\n      [METHODS.RESOURCES.LIST]: this.handleResourcesList.bind(this),\n      [METHODS.RESOURCES.TEMPLATES_LIST]:\n        this.handleResourceTemplatesList.bind(this),\n      [METHODS.RESOURCES.READ]: this.handleResourcesRead.bind(this),\n      [METHODS.RESOURCES.SUBSCRIBE]: this.handleNotImplemented.bind(this),\n      [METHODS.NOTIFICATIONS.CANCELLED]:\n        this.handleNotificationCancelled.bind(this),\n      [METHODS.NOTIFICATIONS.INITIALIZED]:\n        this.handleNotificationInitialized.bind(this),\n      [METHODS.NOTIFICATIONS.PROGRESS]:\n        this.handleNotificationProgress.bind(this),\n      [METHODS.NOTIFICATIONS.ROOTS.LIST_CHANGED]:\n        this.handleNotificationRootsListChanged.bind(this),\n      [METHODS.LOGGING.SET_LEVEL]: this.handleLoggingSetLevel.bind(this),\n      [METHODS.RESOURCES.UNSUBSCRIBE]: this.handleNotImplemented.bind(this),\n      [METHODS.COMPLETION.COMPLETE]: this.handleNotImplemented.bind(this),\n    };\n  }\n\n  /**\n   * Add middleware to the server request pipeline.\n   *\n   * Middleware functions execute in the order they are added, before the actual\n   * request handler. They can modify the context, implement authentication,\n   * add logging, etc.\n   *\n   * @param middleware - Middleware function to add\n   * @returns This server instance for chaining\n   *\n   * @example\n   * ```typescript\n   * server.use(async (ctx, next) => {\n   *   console.log(`Received ${ctx.request.method} request`);\n   *   ctx.state.startTime = Date.now();\n   *   await next();\n   *   console.log(`Request took ${Date.now() - ctx.state.startTime}ms`);\n   *   if (ctx.response?.result) {\n   *     console.log(\"Tool executed successfully:\", ctx.response.result);\n   *   }\n   * });\n   * ```\n   */\n  use(middleware: Middleware): this {\n    this.middlewares.push(middleware);\n    return this;\n  }\n\n  /**\n   * Set a custom error handler for the server.\n   *\n   * The error handler receives all unhandled errors and can return custom\n   * JSON-RPC error responses or return undefined to use default error handling.\n   *\n   * @param handler - Error handler function\n   * @returns This server instance for chaining\n   *\n   * @example\n   * ```typescript\n   * server.onError((error, ctx) => {\n   *   if (error instanceof AuthError) {\n   *     return {\n   *       code: -32001,\n   *       message: \"Authentication required\",\n   *       data: { requestId: ctx.requestId }\n   *     };\n   *   }\n   *   // Return undefined for default error handling\n   * });\n   * ```\n   */\n  onError(handler: OnError): this {\n    this.onErrorHandler = handler;\n    return this;\n  }\n\n  /**\n   * Register a tool that clients can call.\n   *\n   * Tools are functions exposed to MCP clients. They receive validated arguments\n   * and must return content in the ToolCallResult format.\n   *\n   * @template TArgs - Type of the tool's input arguments\n   * @template TOutput - Type of the structured content output\n   * @param name - Unique tool name\n   * @param def - Tool definition with schema, description, handler, and optional metadata\n   * @param def.description - Human-readable description of what the tool does\n   * @param def.title - Optional display title for the tool\n   * @param def._meta - Optional arbitrary metadata object passed through to clients via tools/list\n   * @param def.inputSchema - Schema for validating input arguments (JSON Schema or Standard Schema)\n   * @param def.outputSchema - Schema for validating structured output (JSON Schema or Standard Schema)\n   * @param def.handler - Function that executes the tool logic\n   * @returns This server instance for chaining\n   *\n   * @example With JSON Schema\n   * ```typescript\n   * server.tool(\"calculateSum\", {\n   *   description: \"Calculates the sum of two numbers\",\n   *   inputSchema: {\n   *     type: \"object\",\n   *     properties: {\n   *       a: { type: \"number\" },\n   *       b: { type: \"number\" }\n   *     },\n   *     required: [\"a\", \"b\"]\n   *   },\n   *   handler: (args: { a: number; b: number }) => ({\n   *     content: [{ type: \"text\", text: String(args.a + args.b) }]\n   *   })\n   * });\n   * ```\n   *\n   * @example With Standard Schema (Zod) - Full type inference\n   * ```typescript\n   * import { z } from \"zod\";\n   *\n   * const inputSchema = z.object({\n   *   location: z.string()\n   * });\n   *\n   * const outputSchema = z.object({\n   *   temperature: z.number(),\n   *   conditions: z.string()\n   * });\n   *\n   * server.tool(\"getWeather\", {\n   *   description: \"Get weather for a location\",\n   *   inputSchema,\n   *   outputSchema,\n   *   handler: (args) => ({\n   *     // args.location is typed as string \n   *     content: [{ type: \"text\", text: \"Weather data\" }],\n   *     structuredContent: {\n   *       temperature: 22,\n   *       conditions: \"sunny\"\n   *       // Typed and validated! \n   *     }\n   *   })\n   * });\n   * ```\n   *\n   * @example Without schema\n   * ```typescript\n   * server.tool(\"ping\", {\n   *   description: \"Simple ping tool\",\n   *   handler: () => ({\n   *     content: [{ type: \"text\", text: \"pong\" }]\n   *   })\n   * });\n   * ```\n   *\n   * @example With metadata\n   * ```typescript\n   * server.tool(\"experimental-feature\", {\n   *   description: \"An experimental feature\",\n   *   title: \"Experimental Feature\",\n   *   _meta: {\n   *     version: \"0.1.0\",\n   *     stability: \"experimental\",\n   *     tags: [\"beta\", \"preview\"]\n   *   },\n   *   inputSchema: z.object({ input: z.string() }),\n   *   handler: (args) => ({\n   *     content: [{ type: \"text\", text: `Processing: ${args.input}` }]\n   *   })\n   * });\n   * ```\n   */\n  // Overload 1: Both input and output are Standard Schema (full type inference)\n  tool<\n    SInput extends StandardSchemaV1<unknown, unknown>,\n    SOutput extends StandardSchemaV1<unknown, unknown>,\n  >(\n    name: string,\n    def: {\n      description?: string;\n      title?: string;\n      _meta?: { [key: string]: unknown };\n      inputSchema: SInput;\n      outputSchema: SOutput;\n      handler: (\n        args: InferOutput<SInput>,\n        ctx: MCPServerContext,\n      ) =>\n        | Promise<ToolCallResult<InferOutput<SOutput>>>\n        | ToolCallResult<InferOutput<SOutput>>;\n    },\n  ): this;\n\n  // Overload 2: Input is Standard Schema, output is JSON Schema or undefined\n  tool<S extends StandardSchemaV1<unknown, unknown>>(\n    name: string,\n    def: {\n      description?: string;\n      title?: string;\n      _meta?: { [key: string]: unknown };\n      inputSchema: S;\n      outputSchema?: unknown;\n      handler: (\n        args: InferOutput<S>,\n        ctx: MCPServerContext,\n      ) => Promise<ToolCallResult> | ToolCallResult;\n    },\n  ): this;\n\n  // Overload 3: Output is Standard Schema, input is JSON Schema or undefined\n  tool<S extends StandardSchemaV1<unknown, unknown>>(\n    name: string,\n    def: {\n      description?: string;\n      title?: string;\n      _meta?: { [key: string]: unknown };\n      inputSchema?: unknown;\n      outputSchema: S;\n      handler: (\n        args: unknown,\n        ctx: MCPServerContext,\n      ) =>\n        | Promise<ToolCallResult<InferOutput<S>>>\n        | ToolCallResult<InferOutput<S>>;\n    },\n  ): this;\n\n  // Overload 4: JSON Schema or no schema (requires manual typing)\n  tool<TArgs = unknown, TOutput = unknown>(\n    name: string,\n    def: {\n      description?: string;\n      title?: string;\n      _meta?: { [key: string]: unknown };\n      inputSchema?: unknown;\n      outputSchema?: unknown;\n      handler: (\n        args: TArgs,\n        ctx: MCPServerContext,\n      ) => Promise<ToolCallResult<TOutput>> | ToolCallResult<TOutput>;\n    },\n  ): this;\n\n  // Implementation\n  tool<TArgs = unknown>(\n    name: string,\n    def: {\n      description?: string;\n      title?: string;\n      _meta?: { [key: string]: unknown };\n      inputSchema?: unknown | StandardSchemaV1<TArgs>;\n      outputSchema?: unknown | StandardSchemaV1<unknown>;\n      handler: (\n        args: TArgs,\n        ctx: MCPServerContext,\n      ) => Promise<ToolCallResult> | ToolCallResult;\n    },\n  ): this {\n    if (!this.capabilities.tools) {\n      this.capabilities.tools = { listChanged: true };\n    }\n\n    const { resolvedSchema, validator } = resolveSchema(\n      def.inputSchema,\n      this.schemaAdapter,\n    );\n\n    const outputSchemaResolved = resolveSchema(\n      def.outputSchema,\n      this.schemaAdapter,\n    );\n\n    const metadata: Tool = {\n      name,\n      inputSchema: resolvedSchema,\n    };\n    if (def.description) {\n      metadata.description = def.description;\n    }\n    if (def.title) {\n      metadata.title = def.title;\n    }\n    if (def._meta) {\n      metadata._meta = def._meta;\n    }\n    if (outputSchemaResolved.resolvedSchema && def.outputSchema) {\n      metadata.outputSchema = outputSchemaResolved.resolvedSchema;\n    }\n\n    const entry: ToolEntry = {\n      metadata,\n      // TODO - We could avoid this cast if MethodHandler had a generic type for `params` that defaulted to unknown, but here we could pass TArgs\n      handler: def.handler as MethodHandler,\n      validator,\n      outputValidator: outputSchemaResolved.validator,\n    };\n    this.tools.set(name, entry);\n    if (this.initialized) {\n      this.notificationSender?.(undefined, {\n        method: METHODS.NOTIFICATIONS.TOOLS.LIST_CHANGED,\n      });\n    }\n    return this;\n  }\n\n  /**\n   * Register a resource that clients can list and read.\n   *\n   * Resources are URI-identified content that can be static or template-based.\n   * Templates support parameter extraction using Hono-style syntax.\n   *\n   * @param template - URI template string (e.g. \"file://config.json\" or \"github://repos/{owner}/{repo}\")\n   * @param meta - Resource metadata for listing\n   * @param meta.name - Human-readable name for the resource\n   * @param meta.description - Description of what the resource contains\n   * @param meta.mimeType - MIME type of the resource content\n   * @param meta._meta - Optional arbitrary metadata object passed through to clients via resources/list\n   * @param meta.annotations - Optional annotations for the resource\n   * @param handler - Function that returns resource content\n   * @returns This server instance for chaining\n   *\n   * @example Static resource\n   * ```typescript\n   * server.resource(\n   *   \"file://config.json\",\n   *   { description: \"App configuration\", mimeType: \"application/json\" },\n   *   async (uri) => ({\n   *     contents: [{ uri: uri.href, text: JSON.stringify(config) }]\n   *   })\n   * );\n   * ```\n   *\n   * @example Template resource\n   * ```typescript\n   * server.resource(\n   *   \"github://repos/{owner}/{repo}\",\n   *   { description: \"GitHub repository\" },\n   *   async (uri, { owner, repo }) => ({\n   *     contents: [{ uri: uri.href, text: await fetchRepo(owner, repo) }]\n   *   })\n   * );\n   * ```\n   *\n   * @example Resource with metadata\n   * ```typescript\n   * server.resource(\n   *   \"db://records/{id}\",\n   *   {\n   *     name: \"Database Record\",\n   *     description: \"Fetch a record from the database\",\n   *     mimeType: \"application/json\",\n   *     _meta: {\n   *       cacheTtl: 300,\n   *       accessLevel: \"read-only\"\n   *     }\n   *   },\n   *   async (uri, { id }) => ({\n   *     contents: [{ uri: uri.href, text: JSON.stringify({ id, data: \"...\" }) }]\n   *   })\n   * );\n   * ```\n   */\n  resource(\n    template: string,\n    meta: ResourceMeta,\n    handler: ResourceHandler,\n  ): this;\n\n  /**\n   * Register a resource with parameter validation.\n   *\n   * @param template - URI template string with variables\n   * @param meta - Resource metadata for listing\n   * @param validators - Parameter validators (StandardSchema-compatible)\n   * @param handler - Function that returns resource content\n   * @returns This server instance for chaining\n   *\n   * @example With validation\n   * ```typescript\n   * server.resource(\n   *   \"api://users/{userId}\",\n   *   { description: \"User by ID\" },\n   *   { userId: z.string().regex(/^\\d+$/) },\n   *   async (uri, { userId }) => ({\n   *     contents: [{ uri: uri.href, text: JSON.stringify(await getUser(userId)) }]\n   *   })\n   * );\n   * ```\n   */\n  resource(\n    template: string,\n    meta: ResourceMeta,\n    validators: ResourceVarValidators,\n    handler: ResourceHandler,\n  ): this;\n\n  resource(\n    template: string,\n    meta: ResourceMeta,\n    validatorsOrHandler: ResourceVarValidators | ResourceHandler,\n    handler?: ResourceHandler,\n  ): this {\n    if (!this.capabilities.resources) {\n      this.capabilities.resources = { listChanged: true };\n    }\n\n    const actualHandler = handler || (validatorsOrHandler as ResourceHandler);\n    const validators = handler\n      ? (validatorsOrHandler as ResourceVarValidators)\n      : undefined;\n\n    const isStatic = !template.includes(\"{\");\n    const type = isStatic ? \"resource\" : \"resource_template\";\n\n    const matcher = isStatic ? undefined : compileUriTemplate(template);\n\n    const metadata = isStatic\n      ? {\n          uri: template,\n          ...meta,\n        }\n      : {\n          uriTemplate: template,\n          ...meta,\n        };\n\n    const entry: ResourceEntry = {\n      metadata,\n      handler: actualHandler,\n      validators,\n      matcher,\n      type,\n    };\n\n    this.resources.set(template, entry);\n    if (this.initialized) {\n      this.notificationSender?.(undefined, {\n        method: METHODS.NOTIFICATIONS.RESOURCES.LIST_CHANGED,\n      });\n    }\n    return this;\n  }\n\n  /**\n   * Register a prompt that clients can invoke.\n   *\n   * Prompts are templates that generate messages for LLM conversations.\n   * They can accept arguments and return a structured set of messages.\n   *\n   * @template TArgs - Type of the prompt's input arguments\n   * @param name - Unique prompt name\n   * @param def - Prompt definition with schema, description, handler, and optional metadata\n   * @param def.description - Human-readable description of what the prompt does\n   * @param def.title - Optional display title for the prompt\n   * @param def._meta - Optional arbitrary metadata object passed through to clients via prompts/list\n   * @param def.arguments - Array of argument definitions or a Standard Schema for validation\n   * @param def.inputSchema - Alternative to 'arguments' for specifying a validation schema\n   * @param def.handler - Function that generates the prompt messages\n   * @returns This server instance for chaining\n   *\n   * @example Basic prompt\n   * ```typescript\n   * server.prompt(\"greet\", {\n   *   description: \"Generate a greeting message\",\n   *   handler: () => ({\n   *     messages: [{\n   *       role: \"user\",\n   *       content: { type: \"text\", text: \"Hello, how are you?\" }\n   *     }]\n   *   })\n   * });\n   * ```\n   *\n   * @example Prompt with arguments and schema\n   * ```typescript\n   * server.prompt(\"summarize\", {\n   *   description: \"Create a summary prompt\",\n   *   arguments: z.object({\n   *     text: z.string(),\n   *     length: z.enum([\"short\", \"medium\", \"long\"]).optional()\n   *   }),\n   *   handler: (args: { text: string; length?: string }) => ({\n   *     description: \"Summarization prompt\",\n   *     messages: [{\n   *       role: \"user\",\n   *       content: {\n   *         type: \"text\",\n   *         text: `Please summarize this text in ${args.length || \"medium\"} length:\\n\\n${args.text}`\n   *       }\n   *     }]\n   *   })\n   * });\n   * ```\n   *\n   * @example Prompt with metadata\n   * ```typescript\n   * server.prompt(\"research-assistant\", {\n   *   description: \"Research assistant prompt with context\",\n   *   title: \"Research Assistant\",\n   *   _meta: {\n   *     category: \"research\",\n   *     complexity: \"advanced\",\n   *     estimatedTokens: 500\n   *   },\n   *   arguments: [\n   *     { name: \"topic\", description: \"Research topic\", required: true }\n   *   ],\n   *   handler: (args: { topic: string }) => ({\n   *     messages: [{\n   *       role: \"user\",\n   *       content: { type: \"text\", text: `Research ${args.topic}` }\n   *     }]\n   *   })\n   * });\n   * ```\n   */\n  prompt<TArgs = unknown>(\n    name: string,\n    def: {\n      title?: string;\n      description?: string;\n      _meta?: { [key: string]: unknown };\n      arguments?: unknown | StandardSchemaV1<TArgs>;\n      inputSchema?: unknown | StandardSchemaV1<TArgs>;\n      handler: PromptHandler<TArgs>;\n    },\n  ): this {\n    if (!this.capabilities.prompts) {\n      this.capabilities.prompts = { listChanged: true };\n    }\n\n    let validator: unknown;\n    let argumentDefs: PromptArgumentDef[] | undefined;\n\n    if (def.arguments) {\n      if (Array.isArray(def.arguments)) {\n        argumentDefs = def.arguments as PromptArgumentDef[];\n      } else {\n        const { resolvedSchema, validator: schemaValidator } = resolveSchema(\n          def.arguments,\n          this.schemaAdapter,\n        );\n        validator = schemaValidator;\n        argumentDefs = extractArgumentsFromSchema(resolvedSchema);\n      }\n    } else if (def.inputSchema) {\n      const { resolvedSchema, validator: schemaValidator } = resolveSchema(\n        def.inputSchema,\n        this.schemaAdapter,\n      );\n      validator = schemaValidator;\n      argumentDefs = extractArgumentsFromSchema(resolvedSchema);\n    }\n\n    const metadata: PromptMetadata = {\n      name,\n      title: def.title,\n      description: def.description,\n    };\n\n    if (argumentDefs && argumentDefs.length > 0) {\n      metadata.arguments = argumentDefs;\n    }\n\n    if (def._meta) {\n      metadata._meta = def._meta;\n    }\n\n    const entry: PromptEntry = {\n      metadata,\n      handler: def.handler as PromptHandler,\n      validator,\n    };\n\n    this.prompts.set(name, entry);\n\n    if (this.initialized) {\n      // Passing undefined here means the notification only gets broadcast to sessions\n      this.notificationSender?.(undefined, {\n        method: METHODS.NOTIFICATIONS.PROMPTS.LIST_CHANGED,\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Mount a child server into this parent server for composition.\n   *\n   * Enables modular server design by composing multiple McpServer instances.\n   * Uses keep-first semantics: first registered tool/prompt/resource wins,\n   * later duplicates are silently skipped.\n   *\n   * @param child - Child server to mount (flat, no namespacing)\n   * @returns This server instance for chaining\n   *\n   * @see {@link Logger} For configuring logging to track duplicate warnings\n   * @see {@link Middleware} For middleware composition behavior\n   *\n   * @example Flat mounting (no namespacing)\n   * ```typescript\n   * const git = new McpServer({ name: 'git', version: '1.0.0' })\n   *   .tool('clone', { handler: cloneHandler });\n   *\n   * const app = new McpServer({ name: 'app', version: '1.0.0' })\n   *   .group(git);  // tools/list shows 'clone'\n   * ```\n   *\n   * @example Complete example\n   * See examples/composing-servers for a full working example with multiple\n   * child servers, middleware composition, and real-world patterns.\n   */\n  group(child: McpServer): this;\n\n  /**\n   * Mount a child server with namespaced tools and prompts.\n   *\n   * @param prefix - Namespace prefix (e.g., 'git' makes 'clone'  'git/clone')\n   * @param child - Child server to mount\n   * @returns This server instance for chaining\n   *\n   * @see {@link Logger} For configuring logging to track duplicate warnings\n   * @see {@link Middleware} For middleware composition behavior\n   *\n   * @example Prefix namespacing\n   * ```typescript\n   * const git = new McpServer({ name: 'git', version: '1.0.0' })\n   *   .tool('clone', { handler: cloneHandler });\n   *\n   * const app = new McpServer({ name: 'app', version: '1.0.0' })\n   *   .group('git', git);  // tools/list shows 'git/clone'\n   * ```\n   *\n   * @example Complete example\n   * See examples/composing-servers for a full working example with multiple\n   * child servers, middleware composition, and real-world patterns.\n   */\n  group(prefix: string, child: McpServer): this;\n\n  /**\n   * Mount a child server with flexible namespacing options.\n   *\n   * @param options - Namespacing configuration\n   * @param child - Child server to mount\n   * @returns This server instance for chaining\n   *\n   * @see {@link Logger} For configuring logging to track duplicate warnings\n   * @see {@link Middleware} For middleware composition behavior\n   *\n   * @example Suffix namespacing\n   * ```typescript\n   * const claude = new McpServer({ name: 'claude', version: '1.0.0' })\n   *   .tool('generateText', { handler: claudeHandler });\n   *\n   * const app = new McpServer({ name: 'app', version: '1.0.0' })\n   *   .group({ suffix: 'claude' }, claude);  // tools/list shows 'generateText_claude'\n   * ```\n   *\n   * @example Both prefix and suffix\n   * ```typescript\n   * .group({ prefix: 'ai', suffix: 'v2' }, server);  // 'ai/generateText_v2'\n   * ```\n   */\n  group(options: { prefix?: string; suffix?: string }, child: McpServer): this;\n\n  group(\n    prefixOrOptionsOrChild:\n      | string\n      | { prefix?: string; suffix?: string }\n      | McpServer,\n    child?: McpServer,\n  ): this {\n    let prefix = \"\";\n    let suffix = \"\";\n    let childServer: McpServer;\n\n    if (typeof prefixOrOptionsOrChild === \"string\") {\n      // .group(\"prefix\", child)\n      prefix = prefixOrOptionsOrChild;\n      childServer = child as McpServer;\n    } else if (prefixOrOptionsOrChild instanceof McpServer) {\n      // .group(child)\n      childServer = prefixOrOptionsOrChild;\n    } else {\n      // .group({ prefix?, suffix? }, child)\n      prefix = prefixOrOptionsOrChild.prefix || \"\";\n      suffix = prefixOrOptionsOrChild.suffix || \"\";\n      childServer = child as McpServer;\n    }\n\n    this.mountChild(prefix, suffix, childServer);\n    return this;\n  }\n\n  /**\n   * Export registries snapshot for child server mounting.\n   * Used internally by .group() to compose servers.\n   * @internal\n   */\n  protected _exportRegistries(): {\n    tools: Array<{ name: string; entry: ToolEntry }>;\n    prompts: Array<{ name: string; entry: PromptEntry }>;\n    resources: Array<{ template: string; entry: ResourceEntry }>;\n  } {\n    return {\n      tools: Array.from(this.tools.entries()).map(([name, entry]) => ({\n        name,\n        entry,\n      })),\n      prompts: Array.from(this.prompts.entries()).map(([name, entry]) => ({\n        name,\n        entry,\n      })),\n      resources: Array.from(this.resources.entries()).map(\n        ([template, entry]) => ({ template, entry }),\n      ),\n    };\n  }\n\n  /**\n   * Export middlewares snapshot for child server mounting.\n   * Used internally by .group() to compose middleware chains.\n   * @internal\n   */\n  protected _exportMiddlewares(): Middleware[] {\n    return [...this.middlewares];\n  }\n\n  /**\n   * Wrap a tool or prompt handler with child middlewares for composition.\n   * Ensures child middlewares run around the handler while parent middlewares\n   * run around the entire wrapped handler.\n   * @internal\n   */\n  private wrapWithMiddlewares(\n    mws: Middleware[],\n    handler: MethodHandler,\n  ): MethodHandler {\n    return async (params, ctx) => {\n      let result: unknown;\n      let handlerCalled = false;\n\n      await runMiddlewares(mws, ctx, async () => {\n        result = await handler(params, ctx);\n        handlerCalled = true;\n      });\n\n      if (!handlerCalled) {\n        this.logger.error(\n          \"[mcp-lite] Handler was not executed. A middleware in the child server's middleware chain did not call next(). This is a server configuration issue.\",\n        );\n        throw new RpcError(\n          JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n          \"Internal server error\",\n        );\n      }\n\n      return result;\n    };\n  }\n\n  /**\n   * Wrap a resource handler with child middlewares for composition.\n   * Ensures child middlewares run around the handler while parent middlewares\n   * run around the entire wrapped handler.\n   * @internal\n   */\n  private wrapResourceHandler(\n    mws: Middleware[],\n    handler: ResourceHandler,\n  ): ResourceHandler {\n    return async (uri, vars, ctx) => {\n      let result: ResourceReadResult | undefined;\n      let handlerCalled = false;\n\n      await runMiddlewares(mws, ctx, async () => {\n        result = await handler(uri, vars, ctx);\n        handlerCalled = true;\n      });\n\n      if (!handlerCalled) {\n        this.logger.error(\n          \"[mcp-lite] Resource handler was not executed. A middleware in the child server's middleware chain did not call next(). This is a server configuration issue.\",\n        );\n        throw new RpcError(\n          JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n          \"Internal server error\",\n        );\n      }\n\n      if (!result) {\n        this.logger.error(\n          \"[mcp-lite] Resource handler returned no result. This is a server implementation issue.\",\n        );\n        throw new RpcError(\n          JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n          \"Internal server error\",\n        );\n      }\n\n      return result;\n    };\n  }\n\n  /**\n   * Mount a child server into this parent server.\n   * Implements keep-first semantics: first registered tool/prompt/resource wins,\n   * duplicates are silently skipped.\n   * @internal\n   */\n  private mountChild(prefix: string, suffix: string, child: McpServer): void {\n    /**\n     * Adds prefix or suffix to a tool name before mounting\n     */\n    const buildScopedName = (originalName: string) => {\n      let scopedName = originalName;\n      if (prefix) scopedName = `${prefix}/${scopedName}`;\n      if (suffix) scopedName = `${scopedName}_${suffix}`;\n      return scopedName;\n    };\n    const regs = child._exportRegistries();\n    const childMWs = child._exportMiddlewares();\n    let addedTools = 0;\n    let addedPrompts = 0;\n    let addedResources = 0;\n\n    for (const { name, entry } of regs.tools) {\n      const qualifiedName = buildScopedName(name);\n      if (!this.tools.has(qualifiedName)) {\n        const wrappedHandler =\n          childMWs.length > 0\n            ? this.wrapWithMiddlewares(childMWs, entry.handler)\n            : entry.handler;\n\n        const wrappedEntry: ToolEntry = {\n          metadata: { ...entry.metadata, name: qualifiedName },\n          handler: wrappedHandler,\n          validator: entry.validator,\n          outputValidator: entry.outputValidator,\n        };\n\n        this.tools.set(qualifiedName, wrappedEntry);\n        addedTools++;\n      } else {\n        this.logger.warn(\n          `[mcp-lite] Tool '${qualifiedName}' already exists, skipping duplicate from child server. ` +\n            `This follows keep-first semantics where the first registered tool wins.`,\n        );\n      }\n    }\n\n    for (const { name, entry } of regs.prompts) {\n      const qualifiedName = buildScopedName(name);\n      if (!this.prompts.has(qualifiedName)) {\n        const wrappedHandler =\n          childMWs.length > 0\n            ? (this.wrapWithMiddlewares(\n                childMWs,\n                entry.handler as MethodHandler,\n              ) as PromptHandler)\n            : entry.handler;\n\n        const wrappedEntry: PromptEntry = {\n          metadata: { ...entry.metadata, name: qualifiedName },\n          handler: wrappedHandler,\n          validator: entry.validator,\n        };\n\n        this.prompts.set(qualifiedName, wrappedEntry);\n        addedPrompts++;\n      } else {\n        this.logger.warn(\n          `[mcp-lite] Prompt '${qualifiedName}' already exists, skipping duplicate from child server. ` +\n            `This follows keep-first semantics where the first registered prompt wins.`,\n        );\n      }\n    }\n\n    for (const { template, entry } of regs.resources) {\n      if (!this.resources.has(template)) {\n        const wrappedHandler =\n          childMWs.length > 0\n            ? this.wrapResourceHandler(childMWs, entry.handler)\n            : entry.handler;\n\n        const wrappedEntry: ResourceEntry = {\n          ...entry,\n          handler: wrappedHandler,\n        };\n\n        this.resources.set(template, wrappedEntry);\n        addedResources++;\n      } else {\n        this.logger.warn(\n          `[mcp-lite] Resource '${template}' already exists, skipping duplicate from child server. ` +\n            `This follows keep-first semantics where the first registered resource wins.`,\n        );\n      }\n    }\n\n    if (addedTools > 0 && !this.capabilities.tools) {\n      this.capabilities.tools = { listChanged: true };\n    }\n    if (addedPrompts > 0 && !this.capabilities.prompts) {\n      this.capabilities.prompts = { listChanged: true };\n    }\n    if (addedResources > 0 && !this.capabilities.resources) {\n      this.capabilities.resources = { listChanged: true };\n    }\n\n    if (this.initialized) {\n      if (addedTools > 0) {\n        this.notificationSender?.(undefined, {\n          method: METHODS.NOTIFICATIONS.TOOLS.LIST_CHANGED,\n        });\n      }\n      if (addedPrompts > 0) {\n        this.notificationSender?.(undefined, {\n          method: METHODS.NOTIFICATIONS.PROMPTS.LIST_CHANGED,\n        });\n      }\n      if (addedResources > 0) {\n        this.notificationSender?.(undefined, {\n          method: METHODS.NOTIFICATIONS.RESOURCES.LIST_CHANGED,\n        });\n      }\n    }\n  }\n\n  /**\n   * Set the notification sender for streaming notifications.\n   * This is called by the transport to wire up notification delivery.\n   */\n  _setNotificationSender(\n    sender: (\n      sessionId: string | undefined,\n      notification: { method: string; params?: unknown },\n      options?: { relatedRequestId?: string },\n    ) => Promise<void> | void,\n  ): void {\n    this.notificationSender = sender;\n  }\n\n  /**\n   * Set the client request sender for elicitation and other client requests.\n   * This is called by the transport to wire up client request delivery.\n   */\n  _setClientRequestSender(\n    sender: (\n      sessionId: string | undefined,\n      request: JsonRpcReq,\n      options?: { relatedRequestId?: string | number; timeout_ms?: number },\n    ) => Promise<JsonRpcRes>,\n  ): void {\n    this.clientRequestSender = sender;\n  }\n\n  async _dispatch(\n    message: JsonRpcReq | JsonRpcNotification,\n    contextOptions: CreateContextOptions = {},\n  ): Promise<JsonRpcRes | null> {\n    const isNotification = isJsonRpcNotification(message);\n    const requestId = isNotification ? undefined : (message as JsonRpcReq).id;\n\n    const progressToken = getProgressToken(message as JsonRpcMessage);\n\n    const sessionId = contextOptions.sessionId;\n    const progressSender =\n      sessionId && this.notificationSender && progressToken\n        ? (update: unknown) =>\n            this.notificationSender?.(\n              sessionId,\n              {\n                method: METHODS.NOTIFICATIONS.PROGRESS,\n                params: {\n                  progressToken,\n                  ...(update as Record<string, unknown>),\n                },\n              },\n              { relatedRequestId: requestId ?? undefined },\n            )\n        : undefined;\n\n    const ctx = createContext(message as JsonRpcMessage, requestId, {\n      sessionId,\n      sessionProtocolVersion: contextOptions.sessionProtocolVersion,\n      progressToken,\n      progressSender,\n      authInfo: contextOptions.authInfo,\n      clientCapabilities: contextOptions.clientCapabilities,\n      schemaAdapter: this.schemaAdapter,\n      clientRequestSender: this.clientRequestSender,\n    });\n\n    const method = (message as JsonRpcMessage).method;\n    const handler = this.methods[method];\n\n    const tail = async (): Promise<void> => {\n      if (!handler) {\n        if (requestId === undefined) {\n          return;\n        }\n        ctx.response = createJsonRpcError(\n          requestId,\n          new RpcError(\n            JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND,\n            \"Method not found\",\n            method ? { method } : undefined,\n          ).toJson(),\n        );\n        return;\n      }\n\n      const result = await handler(message.params, ctx);\n      if (requestId !== undefined) {\n        ctx.response = createJsonRpcResponse(requestId, result);\n      }\n    };\n\n    try {\n      await runMiddlewares(this.middlewares, ctx, tail);\n\n      if (requestId === undefined) {\n        return null;\n      }\n\n      if (!ctx.response) {\n        return createJsonRpcError(\n          requestId,\n          new RpcError(\n            JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n            \"No response generated\",\n          ).toJson(),\n        );\n      }\n      return ctx.response;\n    } catch (error) {\n      if (requestId === undefined) {\n        return null;\n      }\n\n      if (this.onErrorHandler) {\n        try {\n          const customError = await this.onErrorHandler(error, ctx);\n          if (customError) {\n            return createJsonRpcError(requestId, customError);\n          }\n        } catch (_handlerError) {\n          // onError handler threw, continue with default error handling\n        }\n      }\n\n      return errorToResponse(error, requestId);\n    }\n  }\n\n  private async handleToolsList(\n    _params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<ListToolsResult> {\n    return {\n      tools: Array.from(this.tools.values()).map((t) => t.metadata),\n    };\n  }\n\n  private async handleToolsCall(\n    params: unknown,\n    ctx: MCPServerContext,\n  ): Promise<ToolCallResult> {\n    if (!isObject(params)) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        \"tools/call requires an object with name and arguments\",\n      );\n    }\n\n    const callParams = params as Record<string, unknown>;\n\n    if (!isString(callParams.name)) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        \"tools/call requires a string 'name' field\",\n      );\n    }\n\n    const toolName = callParams.name;\n    const entry = this.tools.get(toolName);\n\n    if (!entry) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND,\n        \"Method not found\",\n        { method: toolName },\n      );\n    }\n\n    let validatedArgs = callParams.arguments;\n    if (entry.validator) {\n      validatedArgs = ctx.validate(entry.validator, callParams.arguments);\n    }\n\n    const result = (await entry.handler(validatedArgs, ctx)) as ToolCallResult;\n\n    // Validate structured content if outputSchema provided\n    if (\n      entry.outputValidator &&\n      \"structuredContent\" in result &&\n      !result.isError\n    ) {\n      try {\n        const validated = createValidationFunction(\n          entry.outputValidator,\n          result.structuredContent,\n        );\n        result.structuredContent = validated;\n      } catch (validationError) {\n        throw new RpcError(\n          JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n          `Tool '${toolName}' returned invalid structured content: ${\n            validationError instanceof Error\n              ? validationError.message\n              : String(validationError)\n          }`,\n        );\n      }\n    }\n\n    return result;\n  }\n\n  private async handlePromptsList(\n    _params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<ListPromptsResult> {\n    return {\n      prompts: Array.from(this.prompts.values()).map((p) => p.metadata),\n    };\n  }\n\n  private async handlePromptsGet(\n    params: unknown,\n    ctx: MCPServerContext,\n  ): Promise<PromptGetResult> {\n    if (!isObject(params)) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        \"prompts/get requires an object with name and arguments\",\n      );\n    }\n\n    const getParams = params as Record<string, unknown>;\n\n    if (!isString(getParams.name)) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        \"prompts/get requires a string 'name' field\",\n      );\n    }\n\n    const promptName = getParams.name;\n    const entry = this.prompts.get(promptName);\n\n    if (!entry) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        \"Invalid prompt name\",\n        { name: promptName },\n      );\n    }\n\n    let validatedArgs = getParams.arguments || {};\n    if (entry.validator) {\n      validatedArgs = ctx.validate(entry.validator, getParams.arguments);\n    }\n\n    const result = await entry.handler(validatedArgs, ctx);\n    return result as PromptGetResult;\n  }\n\n  private async handleResourcesList(\n    _params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<ListResourcesResult> {\n    const resources = Array.from(this.resources.values())\n      .filter((entry) => entry.type === \"resource\")\n      .map((entry) => entry.metadata as Resource);\n\n    return { resources };\n  }\n\n  private async handleResourceTemplatesList(\n    _params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<ListResourceTemplatesResult> {\n    const resourceTemplates = Array.from(this.resources.values())\n      .filter((entry) => entry.type === \"resource_template\")\n      .map((entry) => entry.metadata as ResourceTemplate);\n\n    return { resourceTemplates };\n  }\n\n  private async handleResourcesRead(\n    params: unknown,\n    ctx: MCPServerContext,\n  ): Promise<ResourceReadResult> {\n    if (typeof params !== \"object\" || params === null) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        \"resources/read requires an object with uri\",\n      );\n    }\n\n    const readParams = params as Record<string, unknown>;\n\n    if (typeof readParams.uri !== \"string\") {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        \"resources/read requires a string 'uri' field\",\n      );\n    }\n\n    const uri = readParams.uri;\n\n    let matchedEntry: ResourceEntry | null = null;\n    let vars: Record<string, string> = {};\n\n    const directEntry = this.resources.get(uri);\n    if (directEntry?.type === \"resource\") {\n      matchedEntry = directEntry;\n    }\n\n    if (!matchedEntry) {\n      for (const entry of this.resources.values()) {\n        if (entry.type === \"resource_template\" && entry.matcher) {\n          const matchResult = entry.matcher.match(uri);\n          if (matchResult !== null) {\n            matchedEntry = entry;\n            vars = matchResult;\n            break;\n          }\n        }\n      }\n    }\n\n    if (!matchedEntry) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND,\n        \"Method not found\",\n        { uri },\n      );\n    }\n\n    let validatedVars = vars;\n    if (matchedEntry.validators) {\n      validatedVars = {};\n      for (const [key, validator] of Object.entries(matchedEntry.validators)) {\n        if (key in vars) {\n          try {\n            validatedVars[key] = ctx.validate(validator, vars[key]);\n          } catch (validationError) {\n            throw new RpcError(\n              JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n              `Validation failed for parameter '${key}': ${validationError instanceof Error ? validationError.message : String(validationError)}`,\n            );\n          }\n        }\n      }\n      for (const [key, value] of Object.entries(vars)) {\n        if (!(key in matchedEntry.validators)) {\n          validatedVars[key] = value;\n        }\n      }\n    }\n\n    try {\n      const url = { href: uri } as URL;\n      const result = await matchedEntry.handler(url, validatedVars, ctx);\n      return result;\n    } catch (error) {\n      if (error instanceof RpcError) {\n        throw error;\n      }\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n        \"Internal error\",\n        error instanceof Error ? { message: error.message } : error,\n      );\n    }\n  }\n\n  private async handleInitialize(\n    params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<InitializeResult> {\n    if (!isInitializeParams(params)) {\n      throw new RpcError(\n        JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n        \"Invalid initialize parameters\",\n      );\n    }\n\n    const initParams = params;\n    const requested = initParams.protocolVersion;\n\n    // Determine which version to use\n    let negotiatedVersion: string;\n    if (isSupportedVersion(requested)) {\n      // Client requested a version we support - use it\n      negotiatedVersion = requested;\n    } else {\n      // Client requested unsupported version - use our most compatible version (2025-03-26)\n      // Per MCP spec: server responds with version it wants to use, client disconnects if incompatible\n      negotiatedVersion = SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_03_26;\n      this.logger?.warn?.(\n        `Client requested unsupported protocol version ${requested}, negotiating to ${negotiatedVersion}`,\n      );\n    }\n\n    this.initialized = true;\n\n    return {\n      protocolVersion: negotiatedVersion,\n      serverInfo: this.serverInfo,\n      capabilities: this.capabilities,\n    };\n  }\n\n  private async handlePing(): Promise<Record<string, never>> {\n    return {};\n  }\n\n  private async handleNotificationCancelled(\n    _params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<Record<string, never>> {\n    return {};\n  }\n\n  private async handleNotificationInitialized(\n    _params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<Record<string, never>> {\n    return {};\n  }\n\n  private async handleNotificationProgress(\n    _params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<Record<string, never>> {\n    return {};\n  }\n\n  private async handleNotificationRootsListChanged(\n    _params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<Record<string, never>> {\n    return {};\n  }\n\n  private async handleLoggingSetLevel(\n    _params: unknown,\n    _ctx: MCPServerContext,\n  ): Promise<Record<string, never>> {\n    return {};\n  }\n\n  private async handleNotImplemented(\n    _params: unknown,\n    ctx: MCPServerContext,\n  ): Promise<never> {\n    throw new RpcError(JSON_RPC_ERROR_CODES.INTERNAL_ERROR, \"Not implemented\", {\n      method: ctx.request.method,\n    });\n  }\n}\n", "export type EventId = string;\nexport type SessionId = string;\n\nexport interface SessionMeta {\n  protocolVersion: string;\n  clientInfo?: unknown;\n  clientCapabilities?: {\n    elicitation?: Record<string, never>;\n    roots?: Record<string, never>;\n    sampling?: Record<string, never>;\n    [key: string]: unknown;\n  };\n}\n\nexport interface StreamData {\n  nextEventId: number;\n  eventBuffer: EventData[];\n}\n\nexport interface SessionData {\n  meta: SessionMeta;\n  streams: Map<string, StreamData>;\n}\n\nexport interface EventData {\n  id: EventId;\n  message: unknown;\n}\n\nfunction formatEventId(sequenceNumber: number, streamId: string): string {\n  return `${sequenceNumber}#${streamId}`;\n}\n\nfunction parseEventId(eventId: string): {\n  sequenceNumber: number;\n  streamId: string;\n} {\n  const hashIndex = eventId.lastIndexOf(\"#\");\n  if (hashIndex === -1) {\n    throw new Error(`Invalid event ID format: ${eventId}`);\n  }\n  const seqStr = eventId.slice(0, hashIndex);\n  const streamId = eventId.slice(hashIndex + 1);\n  const n = parseInt(seqStr, 10);\n  if (!Number.isFinite(n) || n < 1) {\n    throw new Error(`Invalid sequence number in event ID: ${eventId}`);\n  }\n  return {\n    sequenceNumber: n,\n    streamId,\n  };\n}\n\nexport interface SessionAdapter {\n  generateSessionId(): string;\n  create(id: SessionId, meta: SessionMeta): Promise<SessionData> | SessionData;\n  has(id: SessionId): Promise<boolean> | boolean;\n  get(\n    id: SessionId,\n  ): Promise<SessionData | undefined> | SessionData | undefined;\n  appendEvent(\n    id: SessionId,\n    streamId: string,\n    message: unknown,\n  ): Promise<EventId | undefined> | EventId | undefined;\n  replay(\n    id: SessionId,\n    lastEventId: EventId,\n    write: (eventId: EventId, message: unknown) => Promise<void> | void,\n  ): Promise<void> | void;\n  delete(id: SessionId): Promise<void> | void;\n}\n\n/**\n * InMemorySessionAdapter is a simple session adapter that stores sessions in memory.\n * It is useful for testing and development.\n * It is not recommended for production use, unless you are running a small, simple, single, and long-lived MCP server instance.\n */\nexport class InMemorySessionAdapter implements SessionAdapter {\n  #sessions = new Map<SessionId, SessionData>();\n  maxEventBufferSize: number;\n  constructor({ maxEventBufferSize }: { maxEventBufferSize: number }) {\n    this.maxEventBufferSize = maxEventBufferSize;\n  }\n\n  // TODO - make this configurable\n  generateSessionId(): string {\n    return crypto.randomUUID();\n  }\n\n  create(id: SessionId, meta: SessionMeta) {\n    const session: SessionData = {\n      meta,\n      streams: new Map(),\n    };\n    this.#sessions.set(id, session);\n    return session;\n  }\n\n  has(id: SessionId): boolean {\n    return this.#sessions.has(id);\n  }\n\n  get(id: SessionId) {\n    return this.#sessions.get(id);\n  }\n\n  delete(id: SessionId): void {\n    this.#sessions.delete(id);\n  }\n\n  appendEvent(\n    id: SessionId,\n    streamId: string,\n    message: unknown,\n  ): Promise<EventId | undefined> | EventId | undefined {\n    const session = this.get(id);\n\n    if (!session) {\n      return;\n    }\n\n    // Get or create stream data\n    let streamData = session.streams.get(streamId);\n    if (!streamData) {\n      streamData = {\n        nextEventId: 1,\n        eventBuffer: [],\n      };\n      session.streams.set(streamId, streamData);\n    }\n\n    const eventId = formatEventId(streamData.nextEventId++, streamId);\n\n    // Add to buffer with ring buffer behavior\n    streamData.eventBuffer.push({ id: eventId, message });\n\n    // Trim buffer if it exceeds max size\n    if (streamData.eventBuffer.length > this.maxEventBufferSize) {\n      streamData.eventBuffer = streamData.eventBuffer.slice(\n        -this.maxEventBufferSize,\n      );\n    }\n\n    return eventId;\n  }\n\n  async replay(\n    id: SessionId,\n    lastEventId: EventId,\n    write: (eventId: EventId, message: unknown) => Promise<void> | void,\n  ) {\n    const session = this.#sessions.get(id);\n    if (!session) {\n      return;\n    }\n\n    const { sequenceNumber: lastSeq, streamId: targetStreamId } =\n      parseEventId(lastEventId);\n\n    // Get the target stream data\n    const streamData = session.streams.get(targetStreamId);\n    if (!streamData) {\n      return;\n    }\n\n    // Replay events after lastEventId from the target stream only\n    for (const event of streamData.eventBuffer) {\n      const { sequenceNumber: eventSeq } = parseEventId(event.id);\n      if (eventSeq > lastSeq) {\n        await write(event.id, event.message);\n      }\n    }\n  }\n}\n", "import type { EventId } from \"./session-store.js\";\n\nexport interface StreamWriter {\n  write(message: unknown, eventId?: EventId): void;\n  end(): void;\n}\n\nexport function createSSEStream(options?: { onClose?: () => void }): {\n  stream: ReadableStream<Uint8Array>;\n  writer: StreamWriter;\n} {\n  const encoder = new TextEncoder();\n  let controller: ReadableStreamDefaultController<Uint8Array>;\n  let closed = false;\n\n  const end = (): void => {\n    if (closed) return;\n    closed = true;\n    try {\n      controller.close();\n    } catch (_error) {}\n    try {\n      options?.onClose?.();\n    } catch (_e) {}\n  };\n\n  const stream = new ReadableStream<Uint8Array>({\n    start(c) {\n      controller = c;\n    },\n    cancel() {\n      end();\n    },\n  });\n\n  const writer: StreamWriter = {\n    write(message: unknown, eventId?: EventId): void {\n      if (closed) return;\n      try {\n        let sse = \"\";\n        if (eventId) sse += `id: ${eventId}\\n`;\n        sse += `data: ${JSON.stringify(message)}\\n\\n`;\n        controller.enqueue(encoder.encode(sse));\n      } catch (_error) {\n        end();\n      }\n    },\n    end,\n  };\n\n  return { stream, writer };\n}\n", "import { SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST } from \"../constants.js\";\nimport { RpcError } from \"../errors.js\";\nimport {\n  createJsonRpcError,\n  JSON_RPC_ERROR_CODES,\n  type JsonRpcId,\n} from \"../types.js\";\n\nexport function respondToInvalidJsonRpc() {\n  const errorResponse = createJsonRpcError(\n    null,\n    new RpcError(\n      JSON_RPC_ERROR_CODES.INVALID_REQUEST,\n      \"Invalid JSON-RPC 2.0 message format\",\n    ).toJson(),\n  );\n\n  return new Response(JSON.stringify(errorResponse), {\n    status: 400,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n}\n\nexport function respondToProtocolMismatch(\n  responseId: JsonRpcId,\n  protocolHeader: string,\n  expected?: string | readonly string[],\n) {\n  const expectedVersion = expected || SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST;\n  const errorResponse = createJsonRpcError(\n    responseId,\n    new RpcError(\n      JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n      \"Protocol version mismatch\",\n      {\n        expectedVersion,\n        receivedVersion: protocolHeader,\n      },\n    ).toJson(),\n  );\n\n  return new Response(JSON.stringify(errorResponse), {\n    status: 400,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n}\n\nexport function respondToMissingProtocolHeader(responseId: JsonRpcId) {\n  const errorResponse = createJsonRpcError(\n    responseId,\n    new RpcError(\n      JSON_RPC_ERROR_CODES.INVALID_PARAMS,\n      \"Missing required MCP-Protocol-Version header\",\n      {\n        requiredHeader: \"MCP-Protocol-Version\",\n      },\n    ).toJson(),\n  );\n\n  return new Response(JSON.stringify(errorResponse), {\n    status: 400,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n}\n\n/**\n * Responds with a 400 bad request if the session id is missing\n * @todo - we will want to make this response configurable, so someone can use a response format more tailored to their api conventions (https://github.com/fiberplane/mcp/issues/83)\n * @note - since this validaiton happens at the transport layer, we do not respond with a JSON-RPC error\n */\nexport function respondToMissingSessionId() {\n  return new Response(\"Bad Request: Missing required session ID\", {\n    status: 400,\n    headers: {\n      \"Content-Type\": \"text/plain\",\n    },\n  });\n}\n", "import type { AuthInfo } from \"../auth.js\";\nimport type { ClientRequestAdapter } from \"../client-request-adapter.js\";\nimport {\n  JSON_RPC_VERSION,\n  MCP_LAST_EVENT_ID_HEADER,\n  MCP_PROTOCOL_HEADER,\n  MCP_SESSION_ID_HEADER,\n  SSE_ACCEPT_HEADER,\n  SSE_STREAM_ID,\n  SUPPORTED_MCP_PROTOCOL_VERSIONS,\n  SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST,\n} from \"../constants.js\";\nimport type { McpServer } from \"../core.js\";\nimport { RpcError } from \"../errors.js\";\nimport type { SessionAdapter, SessionMeta } from \"../session-store.js\";\nimport { createSSEStream, type StreamWriter } from \"../sse-writer.js\";\nimport {\n  createJsonRpcError,\n  isGlobalNotification,\n  isJsonRpcNotification,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  JSON_RPC_ERROR_CODES,\n  type JsonRpcNotification,\n  type JsonRpcReq,\n  type JsonRpcRes,\n} from \"../types.js\";\nimport {\n  respondToInvalidJsonRpc,\n  respondToMissingProtocolHeader,\n  respondToMissingSessionId,\n  respondToProtocolMismatch,\n} from \"./http-responses.js\";\n\nfunction parseJsonRpc(body: string): unknown {\n  try {\n    const parsed = JSON.parse(body);\n    return parsed;\n  } catch (_error) {\n    throw new RpcError(JSON_RPC_ERROR_CODES.PARSE_ERROR, \"Invalid JSON\");\n  }\n}\n\nexport interface StreamableHttpTransportOptions {\n  sessionAdapter?: SessionAdapter;\n  clientRequestAdapter?: ClientRequestAdapter;\n  /** Allowed Origin headers for CORS validation  */\n  allowedOrigins?: string[];\n  /** Allowed Host headers for preventing Host header attacks */\n  allowedHosts?: string[];\n}\n\nexport class StreamableHttpTransport {\n  private server?: McpServer;\n  private sessionAdapter?: SessionAdapter;\n  private clientRequestAdapter?: ClientRequestAdapter;\n  private allowedOrigins?: string[];\n  private allowedHosts?: string[];\n  private sessionStreams = new Map<string, StreamWriter>(); // sessionId  GET stream writer\n  private requestStreams = new Map<string, StreamWriter>(); // \"sessionId:requestId\"  POST stream writer\n\n  constructor(options: StreamableHttpTransportOptions = {}) {\n    this.sessionAdapter = options.sessionAdapter;\n    this.clientRequestAdapter = options.clientRequestAdapter;\n    this.allowedOrigins = options.allowedOrigins;\n    this.allowedHosts = options.allowedHosts;\n  }\n\n  private getRequestWriter(\n    sessionId: string,\n    requestId: string | number,\n  ): StreamWriter | undefined {\n    return this.requestStreams.get(`${sessionId}:${requestId}`);\n  }\n\n  private getSessionWriter(sessionId: string): StreamWriter | undefined {\n    return this.sessionStreams.get(sessionId);\n  }\n\n  private cleanupSession(sessionId: string): void {\n    // End and remove session stream\n    const sessionWriter = this.sessionStreams.get(sessionId);\n    if (sessionWriter) {\n      sessionWriter.end();\n    }\n    this.sessionStreams.delete(sessionId);\n\n    // End and remove all request streams for this session\n    for (const [key, writer] of this.requestStreams) {\n      if (key.startsWith(`${sessionId}:`)) {\n        writer.end();\n        this.requestStreams.delete(key);\n      }\n    }\n  }\n\n  private async getClientCapabilities(sessionId: string | null): Promise<\n    | {\n        elicitation?: Record<string, never>;\n        roots?: Record<string, never>;\n        sampling?: Record<string, never>;\n        [key: string]: unknown;\n      }\n    | undefined\n  > {\n    if (!sessionId) {\n      return undefined;\n    }\n\n    // In stateless mode (no sessionAdapter), don't advertise elicitation capability\n    // since synthetic sessionId is never returned to client, causing elicitations to hang\n    if (!this.sessionAdapter) {\n      return {};\n    }\n\n    try {\n      const sessionData = await this.sessionAdapter.get(sessionId);\n      return sessionData?.meta?.clientCapabilities;\n    } catch {\n      return undefined;\n    }\n  }\n\n  private async getSessionProtocolVersion(\n    sessionId: string | null,\n  ): Promise<string | undefined> {\n    if (!sessionId || !this.sessionAdapter) {\n      return undefined;\n    }\n\n    try {\n      const sessionData = await this.sessionAdapter.get(sessionId);\n      return sessionData?.meta?.protocolVersion;\n    } catch {\n      // TODO: Invoke a logger here to warn that the session protocol version could not be fetched\n      return undefined;\n    }\n  }\n\n  private async sendClientRequest(\n    sessionId: string | undefined,\n    request: JsonRpcReq,\n    options?: { relatedRequestId?: string | number; timeout_ms?: number },\n  ): Promise<JsonRpcRes> {\n    if (!this.clientRequestAdapter) {\n      throw new Error(\"Client request adapter not configured\");\n    }\n\n    if (request.id === null || request.id === undefined) {\n      throw new Error(\"Client request must have a valid id\");\n    }\n\n    // Create pending promise for the response\n    const { promise } = this.clientRequestAdapter.createPending(\n      sessionId,\n      request.id,\n      { timeout_ms: options?.timeout_ms },\n    );\n\n    // Create JSON-RPC request message\n    const jsonRpcRequest = {\n      jsonrpc: JSON_RPC_VERSION,\n      id: request.id,\n      method: request.method,\n      params: request.params,\n    };\n\n    // Try to deliver via request stream first if relatedRequestId is provided\n    let delivered = false;\n    if (sessionId && options?.relatedRequestId !== undefined) {\n      const requestWriter = this.getRequestWriter(\n        sessionId,\n        options.relatedRequestId,\n      );\n      if (requestWriter) {\n        requestWriter.write(jsonRpcRequest);\n        delivered = true;\n      }\n    }\n\n    // Fallback to session stream if not delivered via request stream\n    if (!delivered && sessionId) {\n      const sessionWriter = this.getSessionWriter(sessionId);\n      if (sessionWriter) {\n        sessionWriter.write(jsonRpcRequest);\n        delivered = true;\n      }\n    }\n\n    if (!delivered) {\n      // Reject the pending request since we couldn't deliver it\n      this.clientRequestAdapter.rejectPending(\n        sessionId,\n        request.id, // We already checked this is not null/undefined above\n        new Error(\"No active streams to deliver client request\"),\n      );\n      throw new Error(\"No active streams to deliver client request\");\n    }\n\n    return promise as Promise<JsonRpcRes>;\n  }\n\n  bind(\n    server: McpServer,\n  ): (\n    request: Request,\n    options?: { authInfo?: AuthInfo },\n  ) => Promise<Response> {\n    this.server = server;\n\n    // Wire up client request sender if adapter is available\n    if (this.clientRequestAdapter) {\n      server._setClientRequestSender(this.sendClientRequest.bind(this));\n    }\n\n    server._setNotificationSender(async (sessionId, notification, options) => {\n      const jsonRpcNotification = {\n        jsonrpc: JSON_RPC_VERSION,\n        method: notification.method,\n        params: notification.params,\n      };\n\n      if (this.sessionAdapter) {\n        const relatedRequestId = options?.relatedRequestId;\n\n        if (sessionId) {\n          // Always persist to session store for resumability (even if delivered via request stream)\n          let eventId: string | undefined;\n          if (this.sessionAdapter) {\n            eventId = await this.sessionAdapter.appendEvent(\n              sessionId,\n              SSE_STREAM_ID,\n              jsonRpcNotification,\n            );\n          }\n\n          // Try request stream first if we have a relatedRequestId\n          if (relatedRequestId !== undefined) {\n            const requestWriter = this.getRequestWriter(\n              sessionId,\n              relatedRequestId,\n            );\n            if (requestWriter) {\n              requestWriter.write(jsonRpcNotification); // ephemeral delivery\n              return;\n            }\n          }\n\n          // Fallback to session stream\n          const sessionWriter = this.getSessionWriter(sessionId);\n          if (sessionWriter) {\n            sessionWriter.write(jsonRpcNotification, eventId);\n          }\n        }\n\n        // Handle global notifications (broadcast to all sessions)\n        const shouldBroadcastToAllSessions =\n          !sessionId || isGlobalNotification(notification.method);\n        if (shouldBroadcastToAllSessions) {\n          for (const [sid, writer] of this.sessionStreams) {\n            // Don't double-send to the originating session\n            if (sid !== sessionId) {\n              writer.write(jsonRpcNotification);\n            }\n          }\n        }\n      } else {\n        // Stateless mode: deliver to request streams using synthetic session ID\n        if (options?.relatedRequestId && sessionId) {\n          const requestWriter = this.getRequestWriter(\n            sessionId,\n            options.relatedRequestId,\n          );\n          if (requestWriter) {\n            requestWriter.write(jsonRpcNotification);\n          }\n        }\n\n        // Handle global notifications in stateless mode (broadcast to all request streams)\n        const shouldBroadcastToAllRequests =\n          !sessionId || isGlobalNotification(notification.method);\n        if (shouldBroadcastToAllRequests) {\n          for (const [requestKey, writer] of this.requestStreams) {\n            // Don't double-send to the originating request\n            if (!sessionId || !requestKey.startsWith(`${sessionId}:`)) {\n              writer.write(jsonRpcNotification);\n            }\n          }\n        }\n      }\n    });\n\n    return this.handleRequest.bind(this);\n  }\n\n  private async handleRequest(\n    request: Request,\n    options?: { authInfo?: AuthInfo },\n  ): Promise<Response> {\n    if (!this.server) {\n      throw new Error(\"Transport not bound to a server\");\n    }\n\n    if (this.allowedHosts) {\n      const host = request.headers.get(\"Host\");\n      if (host && !this.allowedHosts.includes(host)) {\n        return new Response(\"Forbidden\", { status: 403 });\n      }\n    }\n\n    if (this.allowedOrigins) {\n      const origin = request.headers.get(\"Origin\");\n      if (origin && !this.allowedOrigins.includes(origin)) {\n        return new Response(\"Forbidden\", { status: 403 });\n      }\n    }\n\n    switch (request.method) {\n      case \"POST\":\n        return this.handlePost(request, { authInfo: options?.authInfo });\n      case \"GET\":\n        return this.handleGet(request);\n      case \"DELETE\":\n        return this.handleDelete(request);\n      default: {\n        const errorResponse = createJsonRpcError(\n          null,\n          new RpcError(\n            JSON_RPC_ERROR_CODES.INVALID_REQUEST,\n            \"Method not supported\",\n          ).toJson(),\n        );\n        return new Response(JSON.stringify(errorResponse), {\n          status: 405,\n          headers: {\n            Allow: \"POST, GET, DELETE\",\n          },\n        });\n      }\n    }\n  }\n\n  /**\n   * Validates the MCP-Protocol-Version header based on session version\n   * Returns null if valid, or an error Response if invalid\n   */\n  private validateProtocolHeader(\n    sessionVersion: string | undefined,\n    protocolHeader: string | null,\n    jsonRpcMessage: JsonRpcReq | JsonRpcNotification,\n    isNotification: boolean,\n  ): Response | null {\n    const responseId = isNotification\n      ? null\n      : (jsonRpcMessage as JsonRpcReq).id;\n\n    // For 2025-06-18: header is REQUIRED\n    if (sessionVersion === SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_06_18) {\n      if (!protocolHeader) {\n        return respondToMissingProtocolHeader(responseId);\n      }\n      if (protocolHeader !== sessionVersion) {\n        return respondToProtocolMismatch(\n          responseId,\n          protocolHeader,\n          sessionVersion,\n        );\n      }\n      return null;\n    }\n\n    // For 2025-03-26: header is optional, but if present must match\n    if (sessionVersion === SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_03_26) {\n      if (protocolHeader && protocolHeader !== sessionVersion) {\n        return respondToProtocolMismatch(\n          responseId,\n          protocolHeader,\n          sessionVersion,\n        );\n      }\n      return null;\n    }\n\n    // No session: validate header if present\n    if (\n      protocolHeader &&\n      !SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST.includes(\n        protocolHeader as (typeof SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST)[number],\n      )\n    ) {\n      return respondToProtocolMismatch(\n        responseId,\n        protocolHeader,\n        SUPPORTED_MCP_PROTOCOL_VERSIONS_LIST,\n      );\n    }\n\n    return null;\n  }\n\n  private async handlePost(\n    request: Request,\n    options?: { authInfo?: AuthInfo },\n  ): Promise<Response> {\n    try {\n      const sessionId = request.headers.get(MCP_SESSION_ID_HEADER);\n      const body = await request.text();\n      const jsonRpcMessage = parseJsonRpc(body);\n\n      // Check for batch requests (array of requests)\n      if (Array.isArray(jsonRpcMessage)) {\n        // Batching removed in 2025-06-18, only supported in 2025-03-26\n        let sessionVersion: string | undefined;\n        if (this.sessionAdapter && sessionId) {\n          const session = await this.sessionAdapter.get(sessionId);\n          sessionVersion = session?.meta?.protocolVersion;\n        }\n\n        if (sessionVersion === SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_03_26) {\n          // Process batch for 2025-03-26\n          return this.handleBatchRequest(jsonRpcMessage, sessionId, options);\n        }\n\n        // Reject batching for 2025-06-18 or unknown versions\n        const errorResponse = createJsonRpcError(\n          null,\n          new RpcError(\n            JSON_RPC_ERROR_CODES.INVALID_REQUEST,\n            \"Batch requests are not supported in protocol version 2025-06-18\",\n          ).toJson(),\n        );\n        return new Response(JSON.stringify(errorResponse), {\n          status: 400,\n          headers: { \"Content-Type\": \"application/json\" },\n        });\n      }\n\n      // Check if it's a JSON-RPC response first\n      if (isJsonRpcResponse(jsonRpcMessage)) {\n        if (this.sessionAdapter && !sessionId) {\n          return respondToMissingSessionId();\n        }\n\n        // Handle client response by resolving pending request\n        if (\n          this.clientRequestAdapter &&\n          jsonRpcMessage.id !== null &&\n          jsonRpcMessage.id !== undefined\n        ) {\n          this.clientRequestAdapter.resolvePending(\n            sessionId || undefined,\n            jsonRpcMessage.id,\n            jsonRpcMessage,\n          );\n        }\n\n        return new Response(null, { status: 202 });\n      }\n\n      if (\n        !isJsonRpcNotification(jsonRpcMessage) &&\n        !isJsonRpcRequest(jsonRpcMessage)\n      ) {\n        return respondToInvalidJsonRpc();\n      }\n\n      const isNotification = isJsonRpcNotification(jsonRpcMessage);\n      const isInitializeRequest = jsonRpcMessage.method === \"initialize\";\n      const acceptHeader = request.headers.get(\"Accept\");\n      const protocolHeader = request.headers.get(MCP_PROTOCOL_HEADER);\n\n      // Protocol header enforcement based on session version\n      if (!isInitializeRequest) {\n        let sessionVersion: string | undefined;\n        if (this.sessionAdapter && sessionId) {\n          const session = await this.sessionAdapter.get(sessionId);\n          sessionVersion = session?.meta?.protocolVersion;\n        }\n\n        const validationError = this.validateProtocolHeader(\n          sessionVersion,\n          protocolHeader,\n          jsonRpcMessage,\n          isNotification,\n        );\n        if (validationError) {\n          return validationError;\n        }\n      }\n\n      // Check for missing session ID (except for initialize requests)\n      if (this.sessionAdapter && !sessionId && !isInitializeRequest) {\n        return respondToMissingSessionId();\n      }\n\n      if (\n        !isInitializeRequest &&\n        !isNotification &&\n        acceptHeader?.includes(SSE_ACCEPT_HEADER)\n      ) {\n        return this.handlePostSse({\n          request,\n          jsonRpcRequest: jsonRpcMessage,\n          sessionId,\n          isNotification,\n          authInfo: options?.authInfo,\n        });\n      }\n\n      const response = await this.server?._dispatch(jsonRpcMessage, {\n        sessionId: sessionId || undefined,\n        sessionProtocolVersion: await this.getSessionProtocolVersion(sessionId),\n        authInfo: options?.authInfo,\n        clientCapabilities: await this.getClientCapabilities(sessionId),\n      });\n\n      if (isInitializeRequest && response) {\n        if (this.sessionAdapter) {\n          const sessionId = this.sessionAdapter.generateSessionId();\n\n          // Extract capabilities from initialize params\n          const initParams = (jsonRpcMessage as JsonRpcReq).params as {\n            clientInfo?: unknown;\n            capabilities?: {\n              elicitation?: Record<string, never>;\n              roots?: Record<string, never>;\n              sampling?: Record<string, never>;\n              [key: string]: unknown;\n            };\n          };\n\n          // Use the negotiated protocol version from the response (echoed by core)\n          const negotiatedVersion =\n            (response.result as { protocolVersion?: string })\n              ?.protocolVersion || SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_06_18;\n\n          const sessionMeta: SessionMeta = {\n            protocolVersion: negotiatedVersion,\n            clientInfo: initParams.clientInfo,\n            clientCapabilities: initParams.capabilities, // Store capabilities\n          };\n          await this.sessionAdapter.create(sessionId, sessionMeta);\n          return new Response(JSON.stringify(response), {\n            status: 200,\n            headers: {\n              \"Content-Type\": \"application/json\",\n              [MCP_SESSION_ID_HEADER]: sessionId,\n            },\n          });\n        }\n        return new Response(JSON.stringify(response), {\n          status: 200,\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n        });\n      }\n\n      if (response === null) {\n        return new Response(null, { status: 202 });\n      } else {\n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/json\",\n        };\n\n        if (this.sessionAdapter && !isInitializeRequest) {\n          const sessionId = request.headers.get(MCP_SESSION_ID_HEADER);\n          if (sessionId) {\n            headers[MCP_SESSION_ID_HEADER] = sessionId;\n          }\n        }\n\n        return new Response(JSON.stringify(response), {\n          status: 200,\n          headers,\n        });\n      }\n    } catch (error) {\n      const errorResponse = createJsonRpcError(\n        null,\n        new RpcError(\n          JSON_RPC_ERROR_CODES.PARSE_ERROR,\n          \"Parse error\",\n          error instanceof Error ? error.message : \"Unknown parsing error\",\n        ).toJson(),\n      );\n\n      return new Response(JSON.stringify(errorResponse), {\n        status: 400,\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      });\n    }\n  }\n\n  private async handleBatchRequest(\n    batch: unknown[],\n    sessionId: string | null,\n    options?: { authInfo?: AuthInfo },\n  ): Promise<Response> {\n    const responses: JsonRpcRes[] = [];\n\n    const sessionProtocolVersion =\n      await this.getSessionProtocolVersion(sessionId);\n    const clientCapabilities = await this.getClientCapabilities(sessionId);\n\n    for (const message of batch) {\n      if (!isJsonRpcRequest(message) && !isJsonRpcNotification(message)) {\n        // Invalid message in batch\n        responses.push(\n          createJsonRpcError(\n            null,\n            new RpcError(\n              JSON_RPC_ERROR_CODES.INVALID_REQUEST,\n              \"Invalid JSON-RPC 2.0 message in batch\",\n            ).toJson(),\n          ),\n        );\n        continue;\n      }\n\n      try {\n        const response = await this.server?._dispatch(message, {\n          sessionId: sessionId || undefined,\n          sessionProtocolVersion,\n          authInfo: options?.authInfo,\n          clientCapabilities,\n        });\n\n        if (response !== null && response !== undefined) {\n          responses.push(response);\n        }\n        // Notifications don't get responses\n      } catch (error) {\n        const errorResponse = createJsonRpcError(\n          (message as JsonRpcReq).id || null,\n          new RpcError(\n            JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n            \"Internal error processing batch item\",\n            error instanceof Error ? error.message : \"Unknown error\",\n          ).toJson(),\n        );\n        responses.push(errorResponse);\n      }\n    }\n\n    return new Response(JSON.stringify(responses), {\n      status: 200,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...(this.sessionAdapter && sessionId\n          ? { [MCP_SESSION_ID_HEADER]: sessionId }\n          : {}),\n      },\n    });\n  }\n\n  private async handlePostSse(args: {\n    request: Request;\n    jsonRpcRequest: unknown;\n    sessionId: string | null;\n    isNotification: boolean;\n    authInfo?: AuthInfo;\n  }): Promise<Response> {\n    const { jsonRpcRequest, sessionId, isNotification, authInfo } = args;\n\n    if (isNotification) {\n      return new Response(\n        \"Bad Request: POST SSE requires a request with 'id' (notifications not supported)\",\n        {\n          status: 400,\n        },\n      );\n    }\n\n    const requestId = (jsonRpcRequest as JsonRpcReq).id;\n    if (requestId === null || requestId === undefined) {\n      return new Response(\n        \"Bad Request: POST SSE requires a request with 'id'\",\n        {\n          status: 400,\n        },\n      );\n    }\n\n    // Generate synthetic session ID for stateless mode to enable notification routing\n    const effectiveSessionId = sessionId || crypto.randomUUID();\n\n    const { stream, writer } = createSSEStream({\n      onClose: () => {\n        this.requestStreams.delete(`${effectiveSessionId}:${requestId}`);\n      },\n    });\n\n    // Register this request stream using effective session ID\n    this.requestStreams.set(`${effectiveSessionId}:${requestId}`, writer);\n\n    // Dispatch; route progress/responses to this writer (ephemeral; do not persist)\n    Promise.resolve(\n      this.server?._dispatch(jsonRpcRequest as JsonRpcReq, {\n        sessionId: effectiveSessionId,\n        sessionProtocolVersion:\n          await this.getSessionProtocolVersion(effectiveSessionId),\n        authInfo,\n        clientCapabilities:\n          await this.getClientCapabilities(effectiveSessionId),\n      }),\n    )\n      .then(async (rpcResponse) => {\n        if (rpcResponse !== null) {\n          writer.write(rpcResponse); // omit id for per-request streams\n        }\n      })\n      .catch((err) => {\n        try {\n          const responseId = (jsonRpcRequest as JsonRpcReq).id;\n          if (responseId !== null && responseId !== undefined) {\n            const errorResponse = createJsonRpcError(\n              responseId,\n              new RpcError(\n                JSON_RPC_ERROR_CODES.INTERNAL_ERROR,\n                \"Internal error\",\n                err instanceof Error ? { message: err.message } : err,\n              ).toJson(),\n            );\n            writer.write(errorResponse);\n          }\n        } catch (_) {}\n      })\n      .finally(() => {\n        writer.end();\n        // Ensure cleanup in case onClose wasn't triggered\n        this.requestStreams.delete(`${effectiveSessionId}:${requestId}`);\n      });\n\n    const headers: Record<string, string> = {\n      \"Content-Type\": SSE_ACCEPT_HEADER,\n      Connection: \"keep-alive\",\n    };\n\n    // Add session id to header if sessions are supported\n    if (this.sessionAdapter && sessionId) {\n      headers[MCP_SESSION_ID_HEADER] = sessionId;\n    }\n\n    return new Response(stream as ReadableStream, {\n      status: 200,\n      headers,\n    });\n  }\n\n  private async handleGet(request: Request): Promise<Response> {\n    const accept = request.headers.get(\"Accept\");\n    if (!accept || !accept.includes(SSE_ACCEPT_HEADER)) {\n      return new Response(\n        \"Bad Request: Accept header must be text/event-stream\",\n        {\n          status: 400,\n        },\n      );\n    }\n\n    const protocolHeader = request.headers.get(MCP_PROTOCOL_HEADER);\n    if (\n      protocolHeader &&\n      protocolHeader !== SUPPORTED_MCP_PROTOCOL_VERSIONS.V2025_06_18\n    ) {\n      return new Response(\"Bad Request: Protocol version mismatch\", {\n        status: 400,\n      });\n    }\n\n    if (!this.sessionAdapter) {\n      // Stateless mode does not provide a standalone GET stream\n      return new Response(\"Method Not Allowed\", { status: 405 });\n    }\n\n    const sessionId = request.headers.get(MCP_SESSION_ID_HEADER);\n    if (!sessionId || !(await this.sessionAdapter?.has(sessionId))) {\n      return new Response(\"Bad Request: Invalid or missing session ID\", {\n        status: 400,\n      });\n    }\n\n    if (this.sessionStreams.has(sessionId)) {\n      return new Response(\"Conflict: Stream already exists for session\", {\n        status: 409,\n      });\n    }\n\n    const { stream, writer } = createSSEStream({\n      onClose: () => this.sessionStreams.delete(sessionId),\n    });\n\n    // Register the session stream\n    this.sessionStreams.set(sessionId, writer);\n\n    // Optional resume (store expects suffixed Last-Event-ID: \"<n>#<streamId>\")\n    const lastEventId = request.headers.get(MCP_LAST_EVENT_ID_HEADER);\n    let attemptedReplay = false;\n    if (lastEventId) {\n      attemptedReplay = true;\n      try {\n        await this.sessionAdapter.replay(sessionId, lastEventId, (eid, msg) => {\n          writer.write(msg, eid);\n        });\n      } catch (_error) {\n        writer.end();\n        return new Response(\"Internal Server Error: Replay failed\", {\n          status: 500,\n        });\n      }\n    }\n\n    // Send a JSON-RPC ping to establish the SSE connection if we didn't attempt replay\n    // This is needed because SSE clients expect initial data to confirm the stream is working.\n    // If we attempted replay (even if it returned 0 events), we don't send ping because the\n    // client explicitly requested to resume from a specific point. If no replay was requested,\n    // we send a ping (not awaiting pong) just to establish the connection - this is not\n    // fully spec-compliant but ensures compatibility with MCP inspector (which expects\n    // valid JSON-RPC format) while maintaining SSE stream functionality.\n    if (!attemptedReplay) {\n      const pingNotification = {\n        jsonrpc: JSON_RPC_VERSION,\n        method: \"ping\",\n        params: {},\n      };\n      writer.write(pingNotification);\n    }\n\n    return new Response(stream as ReadableStream, {\n      status: 200,\n      headers: {\n        \"Content-Type\": SSE_ACCEPT_HEADER,\n        Connection: \"keep-alive\",\n        [MCP_SESSION_ID_HEADER]: sessionId,\n      },\n    });\n  }\n\n  private async handleDelete(request: Request): Promise<Response> {\n    const sessionId = request.headers.get(MCP_SESSION_ID_HEADER);\n    if (!this.sessionAdapter) {\n      return new Response(\"Method Not Allowed\", { status: 405 });\n    }\n\n    if (!sessionId) {\n      return new Response(\"Bad Request: Missing session ID\", {\n        status: 400,\n      });\n    }\n\n    this.cleanupSession(sessionId);\n\n    await this.sessionAdapter.delete(sessionId);\n\n    return new Response(null, { status: 200 });\n  }\n}\n", "/**\n * Cook Engineering Manual MCP Wrapper\n *\n * This mcp-lite server acts as a web-accessible wrapper around a Python MCP server\n * that performs OpenAI Vision analysis on engineering documentation stored in Weaviate.\n *\n * Architecture:\n * User \u2192 Claude \u2192 mcp-lite (Cloudflare Worker) \u2192 HTTP \u2192 Python MCP Server \u2192 Weaviate + OpenAI\n */\n\nimport { McpServer, StreamableHttpTransport } from 'mcp-lite';\n\ninterface Env {\n\tPYTHON_MCP_URL: string;\n}\n\n// Create MCP Server instance\nconst server = new McpServer({\n\tname: 'cook-engineering-manual-wrapper',\n\tversion: '1.0.0',\n});\n\n// Tool 1: Search Engineering Manual\nserver.tool('search_engineering_manual', {\n\tdescription: `Search the Cook Engineering Handbook for technical specifications,\nformulas, charts, and guidelines. Use this for questions about fans, motors,\nductwork, HVAC systems, wind zones, seismic zones, etc.\n\nExamples:\n- \"What is the friction loss for round elbows?\"\n- \"Is Missouri a high wind zone?\"\n- \"What are the motor efficiency requirements?\"\n\nThis tool will automatically handle visual content like maps, charts, and diagrams.`,\n\tinputSchema: {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tquery: {\n\t\t\t\ttype: 'string',\n\t\t\t\tdescription: 'The technical question or search query',\n\t\t\t},\n\t\t},\n\t\trequired: ['query'],\n\t},\n\thandler: async (args: { query: string }, ctx) => {\n\t\tconst env = ctx.env as Record<string, string>;\n\t\tconst pythonServerUrl = env.PYTHON_MCP_URL || 'http://localhost:5001';\n\n\t\ttry {\n\t\t\t// Call the Python HTTP wrapper\n\t\t\tconst response = await fetch(`${pythonServerUrl}/call-tool`, {\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t},\n\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\tname: 'search_engineering_manual',\n\t\t\t\t\targuments: { query: args.query },\n\t\t\t\t}),\n\t\t\t});\n\n\t\t\tif (!response.ok) {\n\t\t\t\tthrow new Error(`Python server returned ${response.status}: ${await response.text()}`);\n\t\t\t}\n\n\t\t\tconst result: any = await response.json();\n\n\t\t\treturn {\n\t\t\t\tcontent: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'text' as const,\n\t\t\t\t\t\ttext: result.text || 'No response from server',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\t\t\treturn {\n\t\t\t\tcontent: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'text' as const,\n\t\t\t\t\t\ttext: `Error calling Python MCP server: ${errorMessage}\\n\\nMake sure the Python HTTP wrapper is running at ${pythonServerUrl}`,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tisError: true,\n\t\t\t};\n\t\t}\n\t},\n});\n\n// Tool 2: Get Page Direct\nserver.tool('get_page_direct', {\n\tdescription: `Retrieve a specific page from the Cook Engineering Handbook by page number.\nUse this when you know the exact page you need or when search results reference a specific page.`,\n\tinputSchema: {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tpage_number: {\n\t\t\t\ttype: 'number',\n\t\t\t\tdescription: 'Page number (1-150)',\n\t\t\t},\n\t\t},\n\t\trequired: ['page_number'],\n\t},\n\thandler: async (args: { page_number: number }, ctx) => {\n\t\tconst env = ctx.env as Record<string, string>;\n\t\tconst pythonServerUrl = env.PYTHON_MCP_URL || 'http://localhost:5001';\n\n\t\ttry {\n\t\t\t// Call the Python HTTP wrapper\n\t\t\tconst response = await fetch(`${pythonServerUrl}/call-tool`, {\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t},\n\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\tname: 'get_page_direct',\n\t\t\t\t\targuments: { page_number: args.page_number },\n\t\t\t\t}),\n\t\t\t});\n\n\t\t\tif (!response.ok) {\n\t\t\t\tthrow new Error(`Python server returned ${response.status}: ${await response.text()}`);\n\t\t\t}\n\n\t\t\tconst result: any = await response.json();\n\n\t\t\t// Handle both text and images if present\n\t\t\tconst content: Array<any> = [\n\t\t\t\t{\n\t\t\t\t\ttype: 'text',\n\t\t\t\t\ttext: result.text || 'No content found',\n\t\t\t\t},\n\t\t\t];\n\n\t\t\t// Add images if present\n\t\t\tif (result.images && Array.isArray(result.images)) {\n\t\t\t\tfor (const img of result.images) {\n\t\t\t\t\tcontent.push({\n\t\t\t\t\t\ttype: 'image',\n\t\t\t\t\t\tdata: img.data,\n\t\t\t\t\t\tmimeType: img.mimeType,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn { content };\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\t\t\treturn {\n\t\t\t\tcontent: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'text' as const,\n\t\t\t\t\t\ttext: `Error calling Python MCP server: ${errorMessage}\\n\\nMake sure the Python HTTP wrapper is running at ${pythonServerUrl}`,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tisError: true,\n\t\t\t};\n\t\t}\n\t},\n});\n\n// Tool 3: Health Check\nserver.tool('health_check', {\n\tdescription: 'Check if the Python MCP server is accessible and responding',\n\tinputSchema: {\n\t\ttype: 'object',\n\t\tproperties: {},\n\t},\n\thandler: async (_args, ctx) => {\n\t\tconst env = ctx.env as Record<string, string>;\n\t\tconst pythonServerUrl = env.PYTHON_MCP_URL || 'http://localhost:5001';\n\n\t\ttry {\n\t\t\tconst response = await fetch(`${pythonServerUrl}/health`);\n\t\t\tif (!response.ok) {\n\t\t\t\tthrow new Error(`Server returned ${response.status}`);\n\t\t\t}\n\t\t\tconst data: any = await response.json();\n\t\t\treturn {\n\t\t\t\tcontent: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'text' as const,\n\t\t\t\t\t\ttext: `\u2705 Python MCP server is healthy!\\n\\nStatus: ${JSON.stringify(data, null, 2)}`,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\t\t\treturn {\n\t\t\t\tcontent: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'text' as const,\n\t\t\t\t\t\ttext: `\u274C Python MCP server is NOT accessible at ${pythonServerUrl}\\n\\nError: ${errorMessage}\\n\\nMake sure:\\n1. The Python HTTP wrapper is running (python http_wrapper.py)\\n2. The URL is correct\\n3. For deployed version, use ngrok to expose your local server`,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tisError: true,\n\t\t\t};\n\t\t}\n\t},\n});\n\n// Create transport\nconst transport = new StreamableHttpTransport();\n\n// Bind server to transport to get handler function\nconst mcpHandler = transport.bind(server);\n\n// Export Cloudflare Workers handler\nexport default {\n\tasync fetch(request: Request, env: Env): Promise<Response> {\n\t\t// Pass environment variables through context\n\t\treturn mcpHandler(request, { authInfo: { env } as any });\n\t},\n};\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/Users/scottaskinosie/Documents/hacknight/cloudflare_10-28-25/World-Wild-Web-AI-And-MCP-Hack-Night/cook-mcp-wrapper/src/index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/Users/scottaskinosie/Documents/hacknight/cloudflare_10-28-25/World-Wild-Web-AI-And-MCP-Hack-Night/cook-mcp-wrapper/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/Users/scottaskinosie/Documents/hacknight/cloudflare_10-28-25/World-Wild-Web-AI-And-MCP-Hack-Night/cook-mcp-wrapper/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/Users/scottaskinosie/Documents/hacknight/cloudflare_10-28-25/World-Wild-Web-AI-And-MCP-Hack-Night/cook-mcp-wrapper/src/index.ts\";\n\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/Users/scottaskinosie/Documents/hacknight/cloudflare_10-28-25/World-Wild-Web-AI-And-MCP-Hack-Night/cook-mcp-wrapper/.wrangler/tmp/bundle-Bj5wZp/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/Users/scottaskinosie/Documents/hacknight/cloudflare_10-28-25/World-Wild-Web-AI-And-MCP-Hack-Night/cook-mcp-wrapper/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/Users/scottaskinosie/Documents/hacknight/cloudflare_10-28-25/World-Wild-Web-AI-And-MCP-Hack-Night/cook-mcp-wrapper/.wrangler/tmp/bundle-Bj5wZp/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/Users/scottaskinosie/Documents/hacknight/cloudflare_10-28-25/World-Wild-Web-AI-And-MCP-Hack-Night/cook-mcp-wrapper/.wrangler/tmp/bundle-Bj5wZp/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": ["server"]
}
